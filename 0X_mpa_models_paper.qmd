---
title: "Which Models for What Questions"
author: "Dan Ovando"
format:
  html: 
    toc: true
  pdf:
    toc: true
bibliography: references.bib
---

```{r}
#|label: setup

foos <- list.files(here::here("R"))

purrr::walk(foos, ~ source(here::here("R", .x)))

prep_run(run_name = "v0.11") # loads packages and creates and returns some global variables for the analysis


difficulties <- c("simple","medium","complex")

min_depletion <- 0.00001

tune_grids <- FALSE
```


```{r}
#| label: load-results


results <- list.files(results_dir)

results <- results[str_detect(results,"(processed_sims.rds$)|(emulated_experiment_results.rds)|(placement_experiments.rds)|(state_experiments.rds)")]



purrr::walk(results, ~ assign(str_remove_all(.x,"\\.rds$"), read_rds(here(results_dir,.x)), envir = .GlobalEnv))


# process marlin simulations

## get MPA sizes

simple <- simple_state_experiments |> 
  select(state_id, depletion) |> 
  unnest(cols = depletion) |> 
  mutate(difficulty = "simple")

medium <- medium_state_experiments |> 
  select(state_id, depletion) |> 
  unnest(cols = depletion) |> 
  mutate(difficulty = "medium")

complex <- complex_state_experiments |> 
  select(state_id, depletion) |> 
  unnest(cols = depletion) |> 
  mutate(difficulty = "complex")

  state_depletions <- simple |> 
  bind_rows(medium) |> 
  bind_rows(complex) |> 
  mutate(state_id = glue("{difficulty}_{state_id}"))
  
  valid_state_depletions <- state_depletions |> 
    filter(depletion >= min_depletion)


simple <- simple_processed_sims$mpa_outcomes |> 
  mutate(difficulty = "simple")

medium <- medium_processed_sims$mpa_outcomes |> 
  mutate(difficulty = "medium")

complex <- complex_processed_sims$mpa_outcomes |> 
  mutate(difficulty = "complex")

# results of all marlin simulations
highres <- simple |> 
  bind_rows(medium) |> 
  bind_rows(complex) |> 
  mutate(state_id = glue("{difficulty}_{state_id}")) |> 
  mutate(id = glue("{difficulty}-{id}")) |> 
  mutate(prop_mpa = as_factor(prop_mpa))


simple <- simple_emulated_experiment_results |> 
  mutate(difficulty = "simple")

medium <- medium_emulated_experiment_results |> 
  mutate(difficulty = "medium")

complex <- complex_emulated_experiment_results |> 
  mutate(difficulty = "complex")

# results of all PT simulations
lowres <- simple |> 
  bind_rows(medium) |> 
  bind_rows(complex) |> 
  mutate(state_id = glue("{difficulty}_{state_id}")) |> 
  unnest(cols = mpa_experiment) |> 
  filter(year == max(year)) |> 
  mutate(prop_mpa = as_factor(prop_mpa))


tidy_lowres <- lowres |>
  mutate(percent_biomass = b_mpa / b_bau - 1,
         percent_catch = yield_mpa / yield_bau - 1) |>
  select(state_id, prop_mpa, critter, starts_with("percent")) |>
  pivot_longer(
    starts_with("percent"),
    names_to = "name",
    values_to = "lowres_percent_mpa_effect",
    names_prefix = "percent_"
  ) 

highres_vs_lowres <- highres |>
  left_join(tidy_lowres, by = c("state_id", "name", "critter", "prop_mpa")) |> 
  filter(!is.na(lowres_percent_mpa_effect)) |> 
  left_join(state_depletions |> select(state_id, critter, depletion), by = c("state_id","critter")) |> 
  filter(depletion > min_depletion) |> 
  mutate(numeric_prop_mpa = as.numeric(as.character(prop_mpa)))

rm(list = c("simple", "medium", "complex"))


```



## Abstract

## Introduction

The field of ecology depends on models; it is how we move from simply *describing* ecological phenomena to *understanding* ecological processes. All models are abstractions of reality though, requiring scientists to make decisions as to how best to approximate the system in question to address the ecological question at hand. In some cases, these decisions can be be based simply on first principles based on our understanding of the basic physics of the universe. In many other cases we are faced with multiple competing models of the ecological process in question, with a common goal being the search for a "parsimonious" model that best explains the phenomena in question without containing extraneous features that may reduce the performance or efficiency of the model \[citation\]. For example, @murdoch2002 examined under what conditions a single-species model may and may not be a valid representation of a species existing in a multi-specie environment XX.

While the scientific method has employed numerous practices for judging the performance of competing models \[citation\], for much of recent history we have relied largely on confronting models with data, and whether through for example experimentation \[citation\] or predictive skill, as measured for example by various forms of information criteria \[citation\]. Regardless of the method, the key feature here is that models are judged by their ability to explain observed data.

More recently though, the increasing "dimensionality" of questions asked by ecology (e.g. number of species, spatial and temporal scales), combined with the rapid increase in computation capabilities since the XXYEARXX has greatly expanded the use of a slightly different class of model, which we can generally term "simulation models". The key feature of these models is that while they can perhaps be "tuned" to reality based on best available knowledge, they cannot be fit to data in a conventional statistical sense, either due to a lack of degrees of freedom (having many more parameters than available data), or an inability to measure the phenomena being simulated on a reasonable time scale, for example projections of climate drive shifts in species ranges \[citation\].

These simulation models are extremely powerful, particularly as we increasingly turn to ecological sciences to help make complex policy decisions in a dynamic world. For example, the widely used Ecopath with Ecosim modeling framework \[citation\] allows for complex simulation of the effects of environmental and/or policy drivers on marine ecosystems, allowing scientists to ask for example how changes in climate might affect trophic levels of XX \[citation\], a question which cannot be realistically be directly evaluated empirically. However, this power comes with limitations, namely in that without the ability to rely solely on first principles or statistical confrontation with data it is unclear how we should judge the performance of alternative simulation models, particularly if alternative models provide conflicting guidance as to the impact of a phenomena or policy in question.

This challenge is well illustrated by the science of Marine Protected Areas (MPAs). While MPAs have taken and continue to take numerous forms throughout human history \[citation\], we refer to them here broadly as spatially defined areas in which some forms of human activities are restricted xx. Most commonly XX, MPAs involve the restriction of some to all forms of extractive activities such as fishing without their borders \[citation\]. The exact form of these restrictions may vary but the choice of what is implemented is generally made to achieve some policy objective, for example protection of sensitive habitat \[citation\], rebuilding of depleted fish populations \[citation\], and support of food security or economic objectives \[citation\].

The use of MPAs to achieve various policy objectives has exploded in recent years \[citation\] and looks to grow further, as best expressed by the goals of the 30x30 movement, which seeks to place 30% of terrestrial and marine ecosystems in some form of protected area by 2030 \[citation\]. While individual MPAs may differ in their specific objectives, they share a common theme that whatever the policy goal decisions must be made as to how to design a given MPA to achieve a given set of objectives, for example exactly where should the MPA be placed, how big should it be, and exactly what rules will be implemented within its borders.

The difficulty is that baring the most straight-forward of cases (e.g. protection of sensitive habitat of sessile species such as deep-water corals \[citation\]), determining how to design MPAs to achieve a given policy objective is almost entirely dependent on simulation models \[citation\]. This is due in large part to the scale of the processes involved in determining the outcomes of a given MPA or MPA network. Many marine organisms move vast distances at one or more parts of their life cycle \[citation\]. The growth rates of populations are affected by both natural and anthopogenic factors that can change in space and time for exogenous reasons than MPAs.. build this up..

Consider for example the increasing focus on providing spatial protection such as MPAs in the areas beyond national jurisdiction, as embodied by the BBNJ agreement signed in XX. Pelagic ecosystems are characterized by highly mobile species and dynamic habitats. For example, the iconic Atlantic Bluefin Tuna (*Thunnus thynnus*) is capable of moving thousands of kilometers within a year. At the same time.. build this up.

Given then that we cannot realistically design experiments to design networks of high seas MPAs, and lack the vast time series of data before and after MPAs at scale around the world to rely on observational methods, we must turn to simulation modeling to determining how to design MPAs that stand the best chance of achieving our policy objectives. A vast array of simulation models have been developed to fill this gap and help us project the potential policy impacts of MPAs [@fulton2015]. These models vary wildly in complexity, ranging from single species two-patch biomass dynamics models with analytical solutions [@hastings1999] to end-to-end spatially explicit social-ecological models with thousands xx of parameters such as ATLANTIS [@audzijonyte2019]

The question then is what models of MPAs are best suited for addressing which policy questions? The answer is mechanical in some cases. For example, if the goal of a given policy is to increase the mean length of a given target species, at minimum a model that tracks length is required. Conversely, if the goal of a given MPA is to rebuild the trophic structure of a fished ecosystem closer to unfished conditions, at minimum a multi-species model is needed. How though do we determine what model to use across a range of models that are all capable of tracking the same outcomes? For example, two commonly desired outcomes of MPAs are changes in total population biomass and total fishery catches \[citation\]. These metrics, or at least representations of them, are produced both by a two-patch biomass dynamics model and an ATLANTIS model, and essentially every MPA model in between. It is unclear then how to decide which of the many models capable of simulation biomass and catch outcomes of MPAs is parsimonious for the task at hand.

Our hope might be that complexity is additive in nature, which might be expressed by a belief that model complexity is simply a gradient of strategic to tactical, with the key assumption here being that all models capture the core processes around MPAs in an unbiased manner, but some are better capable of capturing finer-scale variation in MPA outcomes related to local context. If this is the case, then we would expect the predictions of say a two-patch biomass dynamics model to be right on average over a region, providing strategic guidance as to the potential outcomes of MPAs in a region, while a more detailed model is needed provide tactical advice for the design of a specific closed area.

While this outcome is ideal, we are unaware of any work that has explicitly tested whether models of increasing MPA complexity fall along the strategic to tactical gradient implicit in much of the MPA modeling literature. Answering this question has real policy implications, particularly because the a wide range of models are currently used to provide advice around MPA models. If these models are not simply increasingly real drawings of the same system, but rather provide fundamentally different predictions of the outcomes of spatial policies such as MPAs (\@fig-cartoon), the predicted effects and subsequent design of MPA networks that will increasingly affect marine ecosystems and dependent peoples may simply be an artifact of an arbitrarily selected type of model rather than a reflection of a robust understanding of the dynamics of these social-ecological systems xx clean this up xx.

To illustrate the potential consequences of diverging predictions of untestable model, consider the case of @sala2021. That paper used a single species two-patch biomass dynamiics modeling framework to predict the conservation and food security outcomes of a proposed global network of no-take MPAs, and as of publication of this paper is among the most highly cited and widely publicized findings in the recent marine conservation literature (<https://nature.altmetric.com/details/101895056>).However, @ovando2023 showed that minor changes to core untestable assumptions of the assumptions made by @sala2021 fundamentally altered both the total predicted outcomes of MPAs for food security and the prioritization map of this proposed global.

The question of exactly what model is appropriate for what question related to spatial policies such as MPAs in marine social-ecological systems if far beyond the scope of this paper. However, this paper seeks to provide a step towards this broader goal by assessing whether models of differing complexity provide complimentary or contradictory predictions of the effects of MPAs across multiple policy dimensions. Specifically, we simulated a range of MPA outcomes using a spatially explicit age structured multi-species and multi-fleet simulation framework presented in @ovando2023a called `marlin`. We then tuned a two-patch biomass dynamics model presented in @ovando2023 and based on @cabral2020, the foundation for the results presented in @sala2021 to emulate the simulated dynamics of the more complex `marlin` model. We then compared the effects of no-take MPAs predicted by these two models, and evaluated if and when the two models were in agreement. We find evidence that rather than existing along a gradient of strategic to tactical, the two models provided vastly different and often contradictory predictions of the outcomes of MPAs for food security and conservation.

## Methods

### Spatially explicit multi species and multi fleet model

#### Simulation Habitats

### Singe species spatially implicit biomass dynamics model

## Results

## Case Study

```{r}
#| label: fig-eg-simple
#| fig-cap: Example simulated effects of MPAs on biomass and catch under the "simple" scenario (High-resolution model only has one species and one fleet). High-resolution model refers to the `marlin` model outputs, Low-resolution model is the two-patch Pella-Tomlinson model. X-axis shows the percent of the seascape protected in a no-take MPA. Y-axis shows biomass divided unfished biomass (A) or catch (B). Panel columns show MPA placement strategy used in High-resolution model. 


i <- 42

i <- as.integer(sample(unique(simple_emulated_experiment_results$state_id),1))

# i <- 48

# test <- simple_state_experiments |> 
#   filter(state_id == 48)

emulation <- simple_emulated_experiment_results |> 
  filter(state_id == i) |> 
  unnest(cols = mpa_experiment) |> 
  filter(year == max(year)) 

reality <- simple_processed_sims$mpa_outcomes |> 
  mutate(state_id = as.integer(state_id)) |> 
  filter(state_id == i)

a = ggplot() +
  geom_line(
    data = reality |> filter(name == "spawning_biomass"),
    aes(prop_mpa, value / ssb0, color = "High-Resolution Model")
  ) +
  geom_point(data = emulation, aes(prop_mpa, depletion_mpa, color = "Low-Resolution Model")) +
  scale_y_continuous(limits = c(0, 1), name = "~B/B0") + 
  scale_x_continuous(name = "MPA Size", labels = scales::percent, guide = guide_axis(n.dodge = 2)) +
  facet_wrap(~placement_strategy) + 
  labs(title = "A") + 
  scale_color_discrete(name = '')

b = ggplot() +
  geom_line(
    data = reality |> filter(name == "catch"),
    aes(prop_mpa, value, color = "High-Resolution Model")
  ) +
  geom_point(data = emulation, aes(prop_mpa, yield_mpa, color = "Low-Resolution Model")) +
  scale_y_continuous(limits = c(0, NA), name = "Catch") + 
  scale_x_continuous(name = "MPA Size", labels = scales::percent, guide = guide_axis(n.dodge = 2)) +
  facet_wrap(~placement_strategy) + 
  labs(title = "B") + 
    scale_color_discrete(name = '')



(a | b) + plot_layout(guides = "collect") & theme(legend.position = "bottom", axis.text.x = element_text(size = 8))


```


```{r}
#| fig-label: fig-eg-complex
#| fig-cap: Example simulated effects of MPAs on biomass and catch under the "complex" scenario (High-resolution model has four species targeted differentially by two fleets). High-resolution model refers to the `marlin` model outputs, Low-resolution model is the two-patch Pella-Tomlinson model. X-axis shows the percent of the seascape protected in a no-take MPA. Y-axis shows biomass divided unfished biomass (A) or catch (B). In *A*, color indicates species points are the Low-resolution model and lines are the high-resolution model. In *B*, color indicates the fleet, and each row of the panel is a separate species. Panel columns show MPA placement strategy used in High-resolution model. 


i <- 42

i <- as.integer(sample(unique(complex_emulated_experiment_results$state_id),1))

emulation <- complex_emulated_experiment_results |> 
  filter(state_id == i) |> 
  unnest(cols = mpa_experiment) |> 
  filter(year == max(year)) 


reality <- complex_processed_sims$mpa_outcomes |> 
  mutate(state_id = as.integer(state_id)) |> 
  filter(state_id == i)


a = ggplot() +
  geom_line(
    data = reality |> filter(name == "spawning_biomass"),
    aes(
      prop_mpa,
      value / ssb0,
      color = critter
    )
  ) +
  geom_point(data = emulation, aes(prop_mpa, depletion_mpa, color = critter)) +
  scale_y_continuous(limits = c(0, NA), name = "~B/B0") +
  scale_x_continuous(name = "MPA Size", labels = scales::percent, guide = guide_axis(n.dodge = 2)) +
  scale_color_viridis_d(name = '') +
  facet_wrap( ~ placement_strategy) + 
  guides(color = guide_legend(nrow = 2))

b = ggplot() +
  geom_line(
    data = reality |> filter(name == "catch") |> mutate(fleet = paste0("High-Resolution Fleet ",fleet)),
    aes(prop_mpa, value, color = fleet)
  ) +
  geom_point(data = emulation |> mutate(fleet = "Low-resolution Fleet"), aes(prop_mpa, yield_mpa, color = fleet)) +
  scale_y_continuous(limits = c(0, NA), name = "Catch") + 
  scale_x_continuous(name = "MPA Size", labels = scales::percent, guide = guide_axis(n.dodge = 2)) +
  facet_grid(critter~placement_strategy,scales = "free") + 
  scale_color_brewer(name = '',palette = "Accent") +
  guides(color = guide_legend(nrow = 2)) + 
  theme(strip.text.y = element_text(size = 6))

(a | b) & theme(legend.position = "bottom", axis.text.x = element_text(size = 8))


```

### Optimal MPA Size

```{r}

# not including for now since somewhat misleading since area != K protected in marlin model

# make a figure plotting yield maximizing MPA size PT vs marlin, and MSY PT vs marlin

# pull out the size and outcome of MPA that maximizes catch for highres and lowres scenarios
highres_max_catch <- highres |> 
  filter(name == "catch") |> 
  group_by(critter, state_id, placement_id) |> 
  filter(value == max(value)) |> 
  select(state_id, critter, placement_id, prop_mpa, value,difficulty,percent_mpa_effect, kiss, spatial_q) |>
  rename(highres_prop_mpa = prop_mpa, highres_catch = value, highres_catch_percent = percent_mpa_effect)

lowres_max_catch <- lowres |> 
  group_by(critter, state_id) |> 
  filter(yield_mpa == max(yield_mpa)) |> 
  mutate(lowres_catch_percent = yield_mpa / yield_bau - 1) |> 
  rename(lowres_prop_mpa = prop_mpa, lowres_catch = yield_mpa)

compare_max_catch_mpa <-  highres_max_catch |>
  right_join(lowres_max_catch, by = c("critter", "state_id", "difficulty"))

```


```{r}
#| label: fig-msy-size
#| fig-cap: "Percent of seascape protected in MPA that maximizes catch predicted by the Highres model (x-axis) and Lowres model (y-axis)"
#| eval: false


compare_max_catch_mpa |>
  mutate(highres_prop_mpa = as.numeric(as.character(highres_prop_mpa))) |> 
  mutate(lowres_prop_mpa = as.numeric(as.character(lowres_prop_mpa))) |> 
  ggplot(aes(highres_prop_mpa, lowres_prop_mpa)) +
  geom_bin_2d(bins = 10) +
  geom_abline(slope = 1, intercept = 0) +
  scale_x_continuous(limits = c(NA, 1), oob = squish, labels = scales::percent, name = "Highres Catch Maximizing MPA") +
  scale_y_continuous(limits = c(NA, 1), oob = squish,labels = scales::percent, name = "Lowres Catch Maximizing MPA") + 
  facet_grid(kiss ~ difficulty) 
```



```{r}
#|label: fig-max-catch
#| fig-cap: "Maximum potential percent increase in catch caused by an MPA predicted by the High-resolution (y-axis) and Low-resolution (x-axis) models. Facets indicate simulation set. "

compare_max_catch_mpa |> 
  ggplot(aes(lowres_catch_percent,highres_catch_percent)) + 
  # geom_bin_2d(bins = 15) + 
  geom_point(aes(color = depletion), alpha = 0.5,size = 2) +
  geom_abline(slope = 1, intercept = 0) + 
  facet_wrap(~fct_rev(difficulty)) + 
  scale_y_continuous(limits = c(NA, 1), oob = squish, labels = scales::percent, name = "High-resolution Maximum Potential Catch Increase") +
  scale_x_continuous(limits = c(NA, 1), oob = squish,labels = scales::percent, name = "Low-resolution Maximum Potential Catch Increase") + 
  scale_color_viridis_b(name = "BAU B/B0", option = "mako", direction = 1) 


```

### Asbolute Agreement


```{r}
#| label: fig-hi-v-low
#| fig-cap: Percent change in biomass (top row) and catch (bottom row) resulting from MPAs covering between 20-40% of the simulated seascape predicted by the High-resolution (x-axis) and Low-resolution (y-axis) models. Panel columns correspond to the simulation set used. Color inducates the biomass divided by unfished biomass (B/B0) under business as usual (BAU) conditions without any MPA. 


highres_vs_lowres |> 
  filter(between(numeric_prop_mpa,0.2,0.4)) |> 
  ggplot(aes(lowres_percent_mpa_effect,percent_mpa_effect, color = depletion)) + 
  geom_hline(yintercept = 0) + 
  geom_vline(xintercept = 0) +
  geom_abline(slope = 1, intercept = 0, color = "tomato") +
    geom_point(alpha = 0.1) + 
  facet_grid(name~difficulty) +
  scale_y_continuous(
    name = "High-resolution % MPA Effect",
    labels = scales::percent,
    limits = c(NA, 2),
    oob = squish
  ) +
  scale_x_continuous(
    name = "Low-resolution % MPA Effect",
    labels = scales::percent,
    limits = c(NA, 2),
    oob = squish
  ) +
  scale_color_viridis_b(name = "BAU B/B0", option = "mako", direction = 1) + 
  theme(legend.position = "top")



```

Biggest mismatch is when MPA causes unintended consequences




```{r}
#| label: fig-delta
#| fig-cap: Distribution of percentage point difference (Low-resolution minus High-resolution) in predicted MPA effect size on biomass (top row) and catch (bottom row) (y-axis) as a function of percent of seascape in MPA (x-axis). Positive y-axis values indicates that the Low-resolution predicts a more positive effect than the High-resolution model, negative a more negative effect. Columns indicate simulation set used. Line is median value, bands are 50% and 90% interquantile ranges, respectively. Color indicates the biomass divided by unfished biomass (B/B0) under business as usual (BAU) conditions without any MPA. 

highres_vs_lowres |>
  mutate(prop_mpa = as.numeric(as.character(prop_mpa))) |> 
  mutate(
    delta =   (pmin(lowres_percent_mpa_effect, 2) - pmin(2, percent_mpa_effect)),
    delta2 = delta ^ 2
  ) |>
  select(contains("percent"), delta2, everything()) |>
  mutate(depbin = cut(depletion,breaks = seq(0,1,by = 0.25))) |> 
  ggplot(aes(prop_mpa,100 * delta , fill = depbin, color = depbin)) +
  geom_hline(yintercept = 0) +
  stat_lineribbon(na.rm = TRUE, alpha = 1/4, .width = c(0.5,0.9)) +
  facet_grid(name ~ fct_rev(difficulty), scales = "free_y") + 
  scale_y_continuous(name = "Percentage Points Difference") + 
  scale_x_continuous(name = "% Seascape in MPA", labels = scales::percent) + 
  scale_color_viridis_d(name = "BAU B/B0", option = "mako", direction = 1) +
  scale_fill_viridis_d(name = "BAU B/B0", option = "mako", direction = 1) + 
  theme(legend.position = "top")


```


```{r}
#| label: fig-ranks
#| fig-cap: Percent rank of individual "fisheries" (intersection of fleet and species) conditional on proportion of seascape protected in a no-take MPA predicted by High-resolution (x-axis) and Low-resolution (y-axis). Higher percent rank indicates that an MPA is predicted to have more positive outcomes for a given fishery, lower worse outcomes. Top row shows results for biomass, bottom row shows results for catch. Columns indicate simulation set. Color indicates the biomass divided by unfished biomass (B/B0) under business as usual (BAU) conditions without any MPA. 

highres_vs_lowres |>
  group_by(prop_mpa, name, difficulty) |>
  mutate(
    highres_rank = percent_rank(percent_mpa_effect),
    lowres_rank = percent_rank(lowres_percent_mpa_effect)
  ) |> 
  arrange(highres_rank, desc(lowres_rank)) |> 
  ggplot(aes(lowres_rank,highres_rank)) + 
  geom_abline(slope = 1, intercept = 0, color = "tomato") +
    geom_point(alpha = 0.05, aes(color = depletion)) +
  facet_grid(name~difficulty, scales = "free") +
  scale_y_continuous(
    name = "Highres % Rank",
    labels = scales::percent,
    limits = c(0, 1),
    oob = squish
  ) +
  scale_x_continuous(
    name = "Lowres % Rank",
    labels = scales::percent,
    limits = c(0, 1),
    oob = squish
  ) +
  scale_color_viridis_b(name = "BAU B/B0", option = "mako", direction = 1) + 
  theme(legend.position = "top")

```

column that says which quadrant it is in for each model
then, whether or not the quadrants agree
then, how often do they agree


Having lowres on the x-axis is saying conditional on testing positive, what's probabilit you have it
having lowres on the y-axis is saying that conditional on having the condition, whats probability that a test tests positive

```{r}
#| label: fig-agreement
#| fig-cap: A) Percent agreement between quadrant predicted by Low-resolution and High-resolution model. Percent values normalized to sum to 100% for each Low-resolution prediction bin. Red dashed diagonla line shows 1:1 line which passes through cells that indicate agreement between Low-resolution and High-resolution models. Grey cells indicate that the Low-resolution model made no prediction in a given quadrant. B) Percent agreement values for a given Low-resolution prediction. Percent of seascape in MPA restricted to between 10-40%. "No Effect" indicates that |percent change| is less than or equal to 5% for both biomass and catch.

# need to do this in a few confusing stages since there are multiple fleets per run
fleet_outcomes <- highres_vs_lowres |>
  filter(name != "biomass") |>
  pivot_longer(contains("percent"),
               names_to = "model",
               values_to = "percent_effect_catch")  |> 
  select(-name)

nature_outcomes <- highres_vs_lowres |>
  filter(name == "biomass") |>
  pivot_longer(contains("percent"),
               names_to = "model",
               values_to = "percent_effect_biomass") |> 
  select(state_id, placement_id, prop_mpa, critter, difficulty, model,percent_effect_biomass,-name)

compare_outcomes <- fleet_outcomes |>
  left_join(nature_outcomes,
            by = join_by(prop_mpa, placement_id, state_id, critter, difficulty, model)) |>
  mutate(
    quadrant = case_when(
      abs(percent_effect_biomass) < 0.05 &
        abs(percent_effect_catch) < 0.05 ~ "No Effect",
      percent_effect_biomass > 0 &
        percent_effect_catch > 0 ~ "Biomass Increases & Catch Increases",
      percent_effect_biomass > 0 &
        percent_effect_catch < 0 ~ "Biomass Increases & Catch Decreases",
      percent_effect_biomass < 0 &
        percent_effect_catch > 0 ~ "Biomass Decreases & Catch Increases",
      percent_effect_biomass < 0 &
        percent_effect_catch < 0 ~ "Biomass Decreases & Catch Decreases"
    )
  ) 

lowres_quadrants <- compare_outcomes |> 
  filter(str_detect(model, "lowres")) |> 
  rename(lowres_quadrant = quadrant)

highres_quadrants <- compare_outcomes |> 
  filter(!str_detect(model, "lowres")) |> 
  rename(highres_quadrant = quadrant) |> 
  select(-matches("percent|model"))

confusion_components <- lowres_quadrants |> 
  left_join(highres_quadrants) |> 
  filter(between(numeric_prop_mpa,0.1,0.4)) 

confusion_matrix <- confusion_components |> 
  left_join(highres_quadrants) |> 
  filter(between(numeric_prop_mpa,0.1,0.4)) |> 
  group_by(highres_quadrant, lowres_quadrant, difficulty) |>
  count() |>
  group_by(difficulty) |>
  mutate(
    highres_quadrant = factor(highres_quadrant),
    lowres_quadrant = factor(lowres_quadrant, levels = levels(highres_quadrant))
  ) |>
  complete(highres_quadrant, lowres_quadrant, fill = list(n = 0)) |>
  group_by(difficulty, lowres_quadrant) |>
  mutate(pn = n / sum(n),
         label_pn = percent(pn, accuracy = 1)) 

confusion_matrix

confusion_matrix_plot <-  confusion_matrix |>
  ggplot(aes(lowres_quadrant, highres_quadrant)) +
  geom_tile(aes(fill = pn), color = "black") +
  geom_abline(
    color = "tomato",
    slope = 1,
    intercept = 0,
    alpha = 0.5,
    linetype = 2
  ) +
  geom_text(aes(label = label_pn), size = 2) +
  facet_wrap(~ fct_rev(difficulty)) +
  scale_fill_gradient(
    low = "white",
    high = "steelblue2",
    name = "% Simulations",
    labels = scales::percent,
    limits = c(0, 1)
  ) +
  theme(axis.text.x = element_text(
    angle = 45,
    vjust = 1,
    hjust = 1
  )) +
  scale_y_discrete(name = "Highres Predicted Quadrant") +
  scale_x_discrete(name = "Lowres Predicted Quadrant") + 
  labs(title = "A") + 
  guides(fill = "none")

agreement_plot <- confusion_matrix |> 
  filter(highres_quadrant == lowres_quadrant) |> 
  group_by(difficulty) |> 
  complete(lowres_quadrant, fill = list(pn = 0)) |>
  ggplot(aes(reorder(highres_quadrant, pn),pn, fill = fct_rev(difficulty))) + 
  geom_col(position = "dodge") + 
  scale_y_continuous(limits = c(0,1), labels = scales::percent, name = "% Agreement") +
  scale_x_discrete(name = "") +
  coord_flip() + 
  scale_fill_viridis_d(name = "Scenario") + 
  labs(title = "B")

confusion_matrix_plot / agreement_plot
```




```{r}
#| label: fig-catch-importance
#| fig-cap: A) Permutation-based variable importance score of included covariates on predictions of model disagreement (Low-resolution minus High-resolution) on catch effects. B) Partial dependency plots of selected covariates. Points are permutted values, lines are.. blue line is..

tmp <- highres_vs_lowres |>
  mutate(delta = pmax(-2, pmin(
    2, lowres_percent_mpa_effect - percent_mpa_effect
  ))) |>
  filter(name == "catch", between(numeric_prop_mpa,0.2, 0.4) )|>
  select(-matches("percent|value|id|numeric|f_v_m")) |>
  mutate(random = rnorm(length(delta))) |>
  filter(is.finite(range_cor), difficulty == "complex")

tmp <- tmp[, which(map_lgl(tmp,  ~ !any(is.na(.x))))]


model_spec <-
  rand_forest(mtry = tune(),
              min_n = tune(),
              trees = tune()) %>%
  set_engine("ranger", importance = "permutation") %>%
  set_mode("regression")

model_recipe <- recipe(delta ~ ., data = tmp)

model_workflow <- 
  workflow() %>% 
  add_model(model_spec) %>% 
  add_recipe(model_recipe)

if (tune_grids | !file.exists(file.path(results_dir,"tuned_catch_grid.rds"))){

tuned_catch_grid <-
  model_workflow %>%
  tune_grid(
    resamples = vfold_cv(tmp,4),
    grid = 10,
    control = control_grid(save_pred = TRUE)
  )

write_rds(tuned_catch_grid, file.path(results_dir,"tuned_catch_grid.rds"))
} else {
  
  tuned_catch_grid <- read_rds(file.path(results_dir,"tuned_catch_grid.rds"))
  
}

best_params <- tune::select_best(tuned_catch_grid, metric = "rmse")

tuned_model_workflow <- model_workflow |> 
  finalize_workflow(best_params)

tuned_fit <- parsnip::fit(tuned_model_workflow, tmp)

catch_vip_plot <- tuned_fit %>% 
  extract_fit_parsnip() %>% 
  vip(num_features = 40) + 
  scale_y_continuous(name = "Permutation-Based Variable Importance") + 
  labs(title = "A)")


explain_fit <- DALEXtra::explain_tidymodels(tuned_fit,
                                       data = tmp, 
                              y = tmp$delta,
                                       label = "rf",
                                       colorize = TRUE,
                                       verbose = FALSE)




pdp_fit  <- model_profile(
  explain_fit,
  variables = c("depletion", "steepness", "ssb0", "adult_diffusion", "habitat_patchiness", "max_cor"),
  type = "partial",
  N = 500
)


pd_plot <- plot(
  pdp_fit,
  geom = "points",
  variables = c(
    "depletion",
    "steepness",
    "adult_diffusion",
    "max_cor"
  )
) +
  theme_minimal() +
  labs(title = "B)", subtitle = '', y = "Predicted Delta")

catch_vip_plot| pd_plot

```


```{r}
#| label: fig-biomass-importance
#| fig-cap: A) Permutation-based variable importance score of included covariates on predictions of model disagreement (Low-resolution minus High-resolution) on biomass effects. B) Partial dependency plots of selected covariates. Points are permutted values, lines are.. blue line is..

tmp <- highres_vs_lowres |>
  mutate(delta = pmax(-2, pmin(
    2, lowres_percent_mpa_effect - percent_mpa_effect
  ))) |>
  filter(name == "biomass", between(numeric_prop_mpa,0.2, 0.4) )|>
  select(-matches("percent|value|id|numeric|f_v_m")) |>
  mutate(random = rnorm(length(delta))) |>
  filter(is.finite(range_cor), difficulty == "complex")

tmp <- tmp[, which(map_lgl(tmp,  ~ !any(is.na(.x))))]


model_spec <-
  rand_forest(mtry = tune(),
              min_n = tune(),
              trees = tune()) %>%
  set_engine("ranger", importance = "permutation") %>%
  set_mode("regression")

model_recipe <- recipe(delta ~ ., data = tmp)

model_workflow <- 
  workflow() %>% 
  add_model(model_spec) %>% 
  add_recipe(model_recipe)


if (tune_grids | !file.exists(file.path(results_dir,"tuned_biomass_grid.rds"))){

tuned_biomass_grid <-
  model_workflow %>%
  tune_grid(
    resamples = vfold_cv(tmp,4),
    grid = 10,
    control = control_grid(save_pred = TRUE)
  )

write_rds(tuned_biomass_grid, file.path(results_dir,"tuned_biomass_grid.rds"))
} else {
  
  tuned_biomass_grid <- read_rds(file.path(results_dir,"tuned_biomass_grid.rds"))
  
}

best_params <- tune::select_best(tuned_biomass_grid, metric = "rmse")

tuned_model_workflow <- model_workflow |> 
  finalize_workflow(best_params)

tuned_fit <- parsnip::fit(tuned_model_workflow, tmp)

biomass_vip_plot <- tuned_fit %>% 
  extract_fit_parsnip() %>% 
  vip(num_features = 40) + 
  scale_y_continuous(name = "Permutation-Based Variable Importance") + 
  labs(title = "A)")

explain_fit <- DALEXtra::explain_tidymodels(tuned_fit,
                                       data = tmp, 
                              y = tmp$delta,
                                       label = "rf",
                                       colorize = TRUE,
                                       verbose = FALSE)




pdp_fit  <- model_profile(
  explain_fit,
  variables = c("depletion", "steepness", "ssb0", "adult_diffusion", "habitat_patchiness", "max_cor"),
  type = "partial",
  N = 500
)


biomass_pd_plot <- plot(
  pdp_fit,
  geom = "points",
  variables = c(
    "depletion",
    "steepness",
    "adult_diffusion",
    "max_cor"
  )
) +
  theme_minimal() +
  labs(title = "B)", subtitle = '', y = "Predicted Delta")

biomass_vip_plot| biomass_pd_plot

```

https://htmlpreview.github.io/?https://github.com/ModelOriented/DALEX-docs/blob/master/vignettes/DALEX_parsnip.html

### Quadrant Agreement



## Discussion

Simple to complex gradient not that information, indicating that much of the difference comes from simply the nature of age structure and 2D populations

Complexity does not equal correctness.

broad areas of agreement
  - depletion effect

Reference spatial stock assessment literature (eventually and in some cases we may have enough data before, after, inside, and outside of MPAs for a range of species to estimate the effect of MPAs within a spatial stock assessment framework, but we're a long way from that.

Cheung style climate projection models

Referecne costello paper on markets for MPAs; what happens if different models bias different results and different regions have access to different kidns of models?

we gave reacged a point in ecology where our ability to model far outstrips our ability to monitor, due to spatial and or temporal scale

How good is good enough

What are the costs of basing something on the wrong model? Direct effects (biomass and catch) and opportunity cost

What do to if can only have the simpelr model? good enough? Under what conditions is doing nother better?

caveat lack of open access dynamics etc. 

While we do not yet have an answer for what model when, we suggest that authors engaged in simulation modeling in this space clearly acknowledge this challenge and provide justification for why they believe the choice of modeling framework presented is appropriate to the question at hand. While computational efficiency clearly plays a role, we suggest that authors should not make this the sole basis for their choice.

## References

## Scraps

```{r}


emulated_model_results <- simple_emulated_experiment_results |>
  select(state_id, prop_mpa, critter, mpa_experiment, depletion) |>
  unnest(cols = mpa_experiment) |>
  filter(year == max(year)) |>
  mutate(rough_f = 1 - depletion)


plot_stuff <- emulated_model_results |>
  mutate(
    yield_effect =   (yield_mpa / yield_bau - 1),
    biomass_effect =  (b_mpa / b_bau - 1)
  ) 

# quad_labels <-
#   data.frame(
#     x = c(50, 50, -25, -25),
#     y = c(50, -50, 50, -50),
#     label = c("Win-Win", "Win-Lose", "Lose-Win", "Lose-Lose")
#   )


lowres_thirty_protected_plot <- plot_stuff |>
  filter(between(prop_mpa, 0.2, 0.4)) |>
  ggplot(aes(biomass_effect,yield_effect, color = depletion)) +
  geom_vline(xintercept = 0, color = "black") +
  geom_hline(yintercept = 0, color = "black") +
  geom_point(alpha = 0.25, size = 3) +
  # geom_text(
  #   data = quad_labels,
  #   aes(x, y, label = label),
  #   size = 6,
  #   color = "red"
  # ) +
  scale_color_viridis_c(
    "BAU Fishing Mortality",
    breaks = c(0,1),
    labels = c("Low","High"),
    limits = c(0, 1),
    option = "plasma",
    guide = guide_colorbar(
      frame.colour = "black",
      ticks.colour = "black",
      barwidth =  unit(11, "lines")
    )
  )  +
  scale_x_continuous(name = "% Change in Species Biomass", limits = c(NA,NA), oob = squish) +
  scale_y_continuous(name = "% Change in Species Catch", oob = squish) +
  theme(legend.position = "bottom") + 
  labs(caption = "20-40% of area in MPA")

lowres_thirty_protected_plot <- ggMarginal(lowres_thirty_protected_plot, type = "histogram", fill = "steelblue") 


lowres_thirty_protected_plot
```

