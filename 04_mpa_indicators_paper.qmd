---
title: "Variability and Detectability of the Effects of Marine Protected Areas on Conservation and Food Security"
author:
  - name: Daniel Ovando
    affiliation:
      - name: Inter-American Tropical Tuna Commission
        department: Ecosystem & Bycatch Group
        id: 1
        address: 8901 La Jolla Shores Drive
        city: La Jolla
        state: CA
        postal-code: 92037
    email: dovando@iattc.org
    attributes:
      equal-contributor: true
      corresponding: true
  - name: Cori Lopazanski
    affiliation:
      - name: UC Santa Barbara
    email: lopazanski@bren.ucsb.edu
    attributes:
      equal-contributor: false
      corresponding: false
format:
  docx: 
    reference-doc: PNASTemplateforMainManuscript.docx
  html: 
    toc: true
    self-contained-math: true
    embed-resources: true
  pdf:
    toc: true
  nature-pdf:
    keep-tex: true
    classoption: [lineno, referee]
    toc: true
    equal-margins: true
bibliography: references.bib
abstract: |
 Something
keywords: [MPA, Simulation Modeling, Model Selection, Conservation Planning, Food Security]
execute: 
  echo: false
  warning: false
---

```{r}
#|label: setup
#|include: false

foos <- list.files(here::here("R"))

purrr::walk(foos, ~ source(here::here("R", .x)))

library(gt)

library(corrr)

prep_run(run_name = "indicators_v0.32",figure_text_size = 11, rx = 20, ry = 20, patch_area = 5^2) # loads packages and creates and returns some global variables for the analysis

Rcpp::sourceCpp(here("src", "select_contiguous_mpa.cpp"))

project <- "indicators"

resolution <- c(rx, ry)

mpa_years <- 24

# clean up figures generated in the report to ensure that all figures come from a fresh state
paper_figs <- file.path(fig_dir,list.files(fig_dir)[list.files(fig_dir) |> str_detect("fig_")])

unlink(paper_figs)

tune_grids <- FALSE

default_observation_error = 0

max_log_indicator <- 1.5
```

```{r}
#| label: load-results
#| include: false


results <- list.files(results_dir)

results <- results[str_detect(results,"(processed_sims.rds$)|(emulated_experiment_results.rds)|(placement_experiments.rds)|(state_experiments.rds)")]



purrr::walk(results, ~ assign(str_remove_all(.x,"\\.rds$"), read_rds(here(results_dir,.x)), envir = .GlobalEnv))

critter_namer <- function(x){
  
  y <- forcats::fct_recode(x,shark = "carcharhinus amblyrhynchos",grouper = "epinephelus fuscoguttatus",snapper = "lutjanus malabaricus", "deep-snapper" = "pristipomoides filamentosus")
  
}


###  calculate BAU the depletion per state  ###


simple <- simple_state_experiments |>
  select(state_id, depletion) |>
  unnest(cols = depletion) |>
  mutate(difficulty = "simple")

medium <- medium_state_experiments |>
  select(state_id, depletion) |>
  unnest(cols = depletion) |>
  mutate(difficulty = "medium")

complex <- complex_state_experiments |>
  select(state_id, depletion) |>
  unnest(cols = depletion) |>
  mutate(difficulty = "complex")

###  stitch difficulty levels together ###
state_depletions <- simple |>
  bind_rows(medium) |>
  bind_rows(complex) |>
  mutate(state_id = glue("{difficulty}_{state_id}"))

simple <- simple_processed_sims$mpa_outcomes |> 
  mutate(difficulty = "simple")

medium <- medium_processed_sims$mpa_outcomes |> 
  mutate(difficulty = "medium")

complex <- complex_processed_sims$mpa_outcomes |> 
  mutate(difficulty = "complex")

# results of all marlin simulations indicators and outcomes
inds_and_outs <- simple |> 
  bind_rows(medium) |> 
  bind_rows(complex) |> 
  mutate(state_id = glue("{difficulty}_{state_id}")) |> 
  mutate(id = glue("{difficulty}-{id}")) |> 
  mutate(prop_mpa = as_factor(prop_mpa)) |> 
  mutate(difficulty = fct_relevel(difficulty,"simple", "medium")) |> 
  filter(step == max(step)) |> # only keep the "final" step, which includes BACI results
  left_join(state_depletions, by = c("critter", "state_id", "difficulty")) |> 
  mutate(across(starts_with("ind_"),\(x) exp(pmin(max_log_indicator,x)) - 1))

# determine viable runs, based on criteria that none of total, MPA, or fished area biomass under BAU should be < 1 (helps prevent runaway percent effect results)
viable_runs <- inds_and_outs |> 
  group_by(name, state_id) |> 
  summarise(min_value = min(control_value)) |> 
  ungroup() |> 
  filter(str_detect(name, "biomass")) |> 
  group_by(state_id) |> 
  summarise(bad_bio = any(min_value < 1)) |> 
  filter(!bad_bio)

inds_and_outs <-  inds_and_outs |> 
  filter(state_id %in% viable_runs$state_id)

# just a quick check
hmm <- inds_and_outs |>
  group_by(name, state_id) |>
  summarise(
    min_value = min(percent_mpa_effect),
    max_value = max(percent_mpa_effect)
  )


rm(list = c("simple", "medium", "complex"))

# calculate average BAU depletion across all critters for multi-critter scenarios
total_state_depletions <- inds_and_outs |> 
  select(critter, state_id, difficulty, depletion, b0) |> 
  unique() |> 
  group_by(state_id, difficulty) |> 
  summarise(mean_depletion = weighted.mean(depletion, b0)) |> 
  ungroup()


###  facilitate outcome comparisons by pulling apart fleet and nature outcomes  ###

fleet_outcomes <- inds_and_outs |>
  select(
    depletion,
    placement_strategy,
    percent_mpa_effect,
    fleet,
    state_id,
    placement_id,
    critter,
    prop_mpa,
    name,
    f_v_m,
    difficulty,
    sigma_rec,
    observation_error
  ) |>
  filter(fleet != "nature") |>
  pivot_wider(names_from = "name", values_from = "percent_mpa_effect")

nature_outcomes <- inds_and_outs |>
  filter(fleet == "nature") |>
  select(ends_with("id"),
         critter,
         prop_mpa,
         name,
         percent_mpa_effect,
         difficulty) |>
  pivot_wider(names_from = "name", values_from = "percent_mpa_effect")

# create dataframe with outcomes as columns for ease of 1:1 comparison 
mpa_outcomes <- fleet_outcomes |>
  left_join(nature_outcomes,
            by = join_by(state_id, placement_id, critter, prop_mpa, difficulty)) |>
  mutate(numeric_prop_mpa = as.numeric(as.character(prop_mpa)))

### create a flatter comparison dataframe that has columns for outcomes and indicators ###


indicators <- inds_and_outs |>
  select(critter,
         prop_mpa,
         state_id,
         placement_id,
         difficulty,
         prop_mpa,
         observation_error,
         starts_with("ind")) |>
  pivot_longer(starts_with("ind_"),
               names_to = "indicator",
               values_to = "indicator_value") |>
  filter(!is.na(indicator_value),
         !str_detect(indicator, "_raw"))
  # this is very important: only use models that control for B0, as proxy for knowing habitat quality

outcomes <- inds_and_outs |>
  select(
    state_id,
    placement_id,
    critter,
    fleet,
    prop_mpa,
    difficulty,
    percent_mpa_effect,
    observation_error,
    name) |> 
  filter(name %in% c("biomass", "mpa_biomass", "catch", "fished_biomass"))

# figure out outcomes by  quadrant instead of by absolute percent effect
quadrant_outcomes <- fleet_outcomes |>
  select(state_id, prop_mpa, placement_id, critter, fleet, difficulty, catch) |>
  left_join(nature_outcomes |> select(state_id, prop_mpa, placement_id, critter, biomass, difficulty),by = join_by(state_id, prop_mpa, placement_id, critter, difficulty)) |>
  pivot_longer(c(catch,biomass)) |>
  mutate(tag = paste(
    name,
    case_when(value > 0.025 ~ "positive", value < -0.025 ~ "negative", .default = "unaffected"),
    sep = ":"
  )) |>
  select(-value) |>
  pivot_wider(names_from = name, values_from = tag) |>
  mutate(quadrant = paste(catch, biomass, sep = " & ")) |>
  left_join(
    inds_and_outs |>
  select(critter,
         prop_mpa,
         state_id,
         placement_id,
         difficulty,
         prop_mpa,
         observation_error,
         starts_with("ind")),
    by = c(
      "critter",
      "state_id",
      "placement_id",
      "prop_mpa",
      "difficulty"
    ),
    relationship = "many-to-many"
  )


comparison <- outcomes |>
  left_join(
    indicators,
    by = c(
      "critter",
      "state_id",
      "placement_id",
      "prop_mpa",
      "difficulty",
      "observation_error"
    ),
    relationship = "many-to-many"
  ) |>
  mutate(prop_mpa = as.numeric(as.character(prop_mpa)))


### repeat but for total outcomes instead of individual species and fleets ###

simple <- simple_total_processed_sims$mpa_outcomes |> 
  mutate(difficulty = "simple")

medium <- medium_total_processed_sims$mpa_outcomes |> 
  mutate(difficulty = "medium")

complex <- complex_total_processed_sims$mpa_outcomes |> 
  mutate(difficulty = "complex")

total_inds_and_outs <- simple |> 
  bind_rows(medium) |> 
  bind_rows(complex) |> 
  mutate(state_id = glue("{difficulty}_{state_id}")) |> 
  mutate(id = glue("{difficulty}-{id}")) |> 
  mutate(prop_mpa = as_factor(prop_mpa)) |> 
  mutate(difficulty = fct_relevel(difficulty,"simple", "medium")) |> 
  filter(step == max(step)) |> 
  left_join(state_depletions, by = c("critter", "state_id", "difficulty")) |> 
  mutate(numeric_prop_mpa = as.numeric(as.character(prop_mpa))) |> 
  filter(state_id %in% viable_runs$state_id)



total_outcomes <- total_inds_and_outs |>
  select(
    state_id,
    placement_id,
    critter,
    fleet,
    prop_mpa,
    difficulty,
    percent_mpa_effect,
    observation_error,
    name) |> 
  filter(name %in% c("biomass", "mpa_biomass", "catch","fished_biomass"))


total_indicators <- total_inds_and_outs |>
  select(
    critter,
    prop_mpa,
    state_id,
    placement_id,
    difficulty,
    prop_mpa,
    observation_error,
    starts_with("ind")
  ) |>
  pivot_longer(starts_with("ind_"),
               names_to = "indicator",
               values_to = "indicator_value") |>
  filter(!is.na(indicator_value), !str_detect(indicator, "_raw"))


total_comparison <- total_outcomes |>
  left_join(
    total_indicators,
    by = c(
      "critter",
      "state_id",
      "placement_id",
      "prop_mpa",
      "difficulty",
      "observation_error"
    ),
    relationship = "many-to-many"
  ) |>
  mutate(prop_mpa = as.numeric(as.character(prop_mpa))) |> 
  left_join(total_state_depletions,by = join_by(state_id, difficulty))

total_mpa_outcomes <- inds_and_outs |>
  group_by(state_id,
           placement_id,
           prop_mpa,
           difficulty,
           name,
           observation_error) |>
  summarise(total_value = sum(value),
            total_control_value = sum(control_value),
            depletion = weighted.mean(depletion, b0)) |>
  mutate(percent_mpa_effect = total_value / total_control_value - 1) |>
  select(-starts_with("total")) |>
  pivot_wider(names_from = name, values_from = percent_mpa_effect) |>
  ungroup() |>
  mutate(numeric_prop_mpa = as.numeric(as.character(prop_mpa)))


```

## Introduction

Various forms of spatial management have been used as a tool to conserve
and manage marine ecosystems across cultures throughout human history
[e.g. @Johannes2002]. The 1990s marked a period of expanded interest in
the science and use of spatial management, specifically the general
concept of "marine protected areas" (MPAs) [@carr2019; @humphreys2020].
While all forms of MPAs share the common features of having defined
spatial boundaries, the exact definitions and objectives of MPAs have
evolved and expanded. Protection levels now span fully no-take MPAs in
which no forms of extractive activity are allowed, to lightly protected
MPAs in which only a subset of activities are prohibited
[@grorud-colvert2021]. Objectives can include perservation of cultural
heritage, rebuilding populations inside borders, providing conservation
benefits outside borders, and supporting fisheries in surrounding waters
[@gaines2010].

Insert IUCN, BBNJ, AIchi, etc.

While the range of outcomes and protections conferred by MPAs varies
widely, the most common type of MPA are those that restrict fishing
activities within their borders in order to achieve some set of
conservation, and sometimes fishery, goals. The science behind this idea
is simple. Removing fishing from a sufficiently large area relative to
the movement dynamics of the species in question can result in an
increase in the numbers and size of animals inside an MPA. Subsequently,
some of these increases inside the MPA can "spill over" to surrounding
waters, through dispersal of larvae or movement of post-recruitment
animals, and in doing so potentially increase populations sizes and
fishing opportunities around the MPA [@gaines2010a].

While the concept is simple, the exact question of how large and where
MPAs should be placed to achieve different objectives has been the
subject of extended debate. All else being equal increasing the size of
an MPA increases the likelihood of meaningful conservation benefits. For
overfished species, it is possible to simultaneously increase catches
along with biomass through use MPAs, but only up to a point; clearly
fisheries cannot benefit from closure of 100% of the seas. The exact
size and placement of MPAs needed to achieve a desired blend of
conservation and fishery outcomes will depend on the specifics of the
system in question then [@hilborn2004a; @gaines2010; @white2011].

XX this is turning into a treatise on MPAs in general, come back and
tighten up, get to the point XX

@hopf2024 assessed relationship between indicators and a set of
conservation outcomes. @hilborn2024 assessed the relationship between
one particular indicator and fishery outcomes. This anaylses builds on
both of those studies by greatly expanding the degree of
social-ecological realism built into the underlying model and assessing
the performance of a range of indicators on conservation and fishery
outcomes and tradeoffs of MPAs.

We argue that part of the reason for the ongoing debate on the expected
outcomes and appropriate design of MPAs stems from problems with the
body of evidence informing the discussion. Much of the early theory of
of MPAs focused on simulation modeling. However, beyond some general
agreement on broad concepts... xx

The expansion of MPAs since the 1990s has seen a commensurate increase
in empirical studies seeking to measure the effects of these MPAs on a
range of outcomes. The most common forms of these have been measurements
of attributes such as biomass density inside or near to MPAs relative to
outside or farther from MPAs, sometimes with measurements both before
and after MPA implementation [@hopf2024; @lester2009; @lynham2024;
@ban2019]. While this body of empirical work is extremely valuable, we
argue that there are two major problems, the first statistical and the
second epistemological , with the interpretation of this literature that
cloud our understanding of the effects of MPAs.

The statistical issues are well documented, and relates to the basic
problems of establishing causality in coupled social-ecological systems
in the absence of a true experimental design. The most reliable way to
determine the causal effects of MPAs would be to run a series of
large-scale experiments randomly deploying MPAs and then tracking their
performance relative to randomly selected control areas. This is clearly
not possible given the spatial and temporal scales involved, meaning
that we must instead rely on imperfect approximations of this ideal
design. The most common form in the literature are before-after and
control-impact studies [@ban2019; @hopf2024]. However, own their own
before-impact studies cannot control for unrelated environmental changes
over the study period, and control-impact studies cannot control for
baseline differences between the two selected areas. Both of these
problems are a type of omitted variable bias, which can result in
estimates of the "MPA effect" being positively or negatively biased,
depending on the magnitude of the omitted variable effect on the outcome
and the degree of correlation of the omitted variable with the variable
of interest (in this case MPA status).

One solution to these problems is to combine the two approaches into a
before-after-control-impact (BACI) study, which in theory can on its own
control for both temporal shocks and baseline differences that might
otherwise bias estimated MPA effects. BACI studies are rarer because
they require greater amounts of data than before-after or control-impact
on their own. While BACI can be a clear improvement, it still relies on
some critical assumptions, importantly for this case what is known as
the "Stable Unit Treatment Value Assumption" (SUTVA), which despite its
nearly unintelligible name simply means that in order for something like
BACI to work as intended, the "impact" units (in this case the MPA)
cannot affect the "control" units (in this case the reference sites
outside the MPA). For example, if closure of an MPA results in
displacement of fishing effort to surrounding waters, and those
surrounding waters are used in a BACI analysis, we have violated SUTVA
since the "impact" site is now affecting our "control" site, and thus
any estimates from BACI in this scenario will be biased.

This topic and its implications for interpretation of the empirical MPA
literature has been discussed extensively, see @ferraro2018,
@larsen2019, @byrnes2025. Despite this, the body of our empirical
knowledge of MPA still depends on these studies that stand a good chance
of being affected to some degree by omitted variable bias, SUTVA, or
both. While our perception is that many users of these methods are aware
of these potential issues, they remain in use because 1) they are often
the only data variable and 2) the hope is that whatever biases may exist
are small relative to the true effect size of interest.

The statistical problem then is that the many MPA studies lack a robust
causal inference strategy that can insulate estimated MPA effects from
omitted variable bias and SUTVA. This means that the effect sizes
produced by these studies are likely to be biased to some degree. We
argue though that even in the cases where the most rigorous causal
inference methods are possible, the empirical MPA literature often faces
an epistemological challenge. This is because we often do not measure
the actual outcome of interest, but rather another outcome that we claim
is a proxy for the broader phenomenon of interest. For example, we might
interpret difference in biomass inside versus outside as being an
indicator of a broader unmeasured variable, such as the change in the
total population of fish xx citation xx. Or we might interpret an
increase in catch per unit effort (CPUE) near an MPA as being indicative
of changes in total fishery catches, despite that not being what was
actually measured xx citation xx. This game of telephone can turn even
reliable estimates of a specific effect (e.g. changes in CPUE) into
unreliable interpretations of another effect (e.g. total catch).

As we expand MPA usage around the world, important that we are able to
accurately measure performance so that we can track progress not just
towards area protected, but outcomes achieved. To that end, this paper
addresses two questions to evaluate the state of empirical evidence for
MPA effects.

1.  Are MPA outcomes variable enough to require ongoing monitoring?

2.  If so, how well do common empirical measures of MPA performance
    represent different desired outcomes?

To answer the first question (*How variable are MPA effects?*), we use a
spatially-explicit multi-species and multi-fleet bio-economic model
[@ovando2023a] to simulate the effect of no-take MPAs on biomass and
catch across a wide range of possible states of the underlying
social-ecological system. To answer the second question (*How well can
MPA effects be measured?*), we generated data from the previously
simulated scenarios and calculated a range of common indicators of MPA
performance, including response ratios, BACI, and spillover gradients
xx, and then compared the values of these indicators to outcomes of
interest (total biomass along with biomass inside and outside MPAs,
total catch).

## Methods

### Simulating MPA Outcomes

Simulated MPA outcomes were generated by the `marlin` model presented in
@ovando2023a. `marlin` simulates a user-specified number of
age-structured fish populations fished by a user-specified number of
fishing fleets, all operating in a two-dimensional space. Within this
broad framework, users can very a wide-range of bio-economic parameters,
ranging from recruitment dynamics and habitat correlations of individual
fished species to gear selectivity and fleet dynamics of individual
fishing fleets. Along with these dynamics, users can also specify
management actions, particularly in this case no-take MPAs. The general
structure for any one simulation run is as follows: - Select a set of
parameters for the simulated bio-economic system - Simulate the system
forward in time without an MPA - Simulate the system forward in time
with a desired number of patches protected in a no-take MPA - Calculate
indicators of MPA performance based on the with-MPA scenario - Calculate
true outcomes of the MPA by comparing values (e.g. total biomass and
catch) per species and per fleet in the simulation with MPAs versus the
paired simulation without MPAs

#### Simulated States

For this paper, we specified three general levels of complexity of the
simulated scenario;*simple*, *medium*, and *complex*. For whatever
species are selected, core life history values (growth, mortality, and
maturity) are pulled from `Fishlife` [@thorson2020] for each individual
species.

Under the *simple* scenario, there is only one fished species (a
snapper, *lutjanus malabaricus*), targeted by one fishing fleet
$\alpha$. Under the *medium* scenario there are now four fished species
*lutjanus malabaricus*, *Pristipomoides filamentosus*, *Epinephelus
fuscoguttatus*, and *Carcharhinus amblyrhynchos*, targeted by one
fishing fleet. Under the *complex scenario*, the same four fished
species are now fished by two different fishing fleets $\alpha$ and
$\beta$, each with their own separate parameters.

One of the key features of `marlin` is the ability to automatically
simulate species distributions with a desired level of hetergeneity and
cross-species correlations, ranging from uniformaly distributed species,
to highly hetergeneous habitat preferences with strong positive or
negative correlations across species. See @ovando2025 for details of the
habitat modeling.

@tbl-states shows the full range of parameters that are randomized in
any given iteration of the model.

::: {#tbl-states}
| Name | Description |
|--------------------------|----------------------------------------------|
| KISS | Keep it Simple Stupid. When TRUE, sets habitat equal in all patches for all species |
| MPA response | Dictates whether effort that used to fish inside MPAs "stays" and is redistributed or "leaves" the fishery |
| Habitat patchiness ($\kappa$) | Low values create smooth habitat, higher values patchy habitat |
| Max absolute correlation | Scales the maximum absolute correlation between species |
| Spatial catchability | Whether catchability of the fishing fleets varies in space |
| Spatial fleet allocation | How the fleet distributes itself in space, one of revenue, profit per unit effort, and revenue per unit effort |
| Seasonal movement | Whether habitat flips in one half of the year to another |
| Spawning aggregation | Whether spawning occurs in a concentrated location |
| Fishing vs. Natural mortality | Ratio of instantaneous fishing mortality rate relative to natural mortality. The higher this is, the lower $B_{bau}/B_0$ will be. |
| Adult diffusion | The diffusion rate of "adult" (non-larval) fish |
| Larval diffusion | The diffusion rate of the larval fish |
| Steepness | Beverton-Holt steepness value |
| b0 | The unfished biomass for a given species |
| Hyperallometry | Degree of hyperallometry in fecundity at age relationship |
| Density dependence | The timing of density dependence, one of "global_habitat", "local_habitat", "pre_dispersal", "post_dispersal". |
| Ontogenetic shift | Whether recruitment habitat is the inverse of adult habitat |
| Use ports? | Whether or not to assign ports to individual fleets that alter cost per unit effort in patches |
| Selectivity at age | Selectivity at age, set separately for every *métier* |
| Selectivity form | one of uniform, logistic, or double-normal, set separately for every *métier* |
| Price per unit weight | Price per unit weight for every *métier* |

Variables that define a given simulation state. See accompanying code at
<https://doi.org/10.5281/zenodo.14503624> XX for details of individual
distributions.
:::

### Empirical Indicators

The simulation framework provides estimates of the true simulated causal
effect of a given MPA on the bio-economic system. We paired these true
outcomes with simplified versions of common empirical indicators of MPA
performance. All indicators were calculated using the simulated data
without any observation error, in order to isolate the fundamental
performance of the indicator from questions around data quality and
bias.

Empirical indicators are often evaluated to some degree based on their
statistical significance (e.g. p \< 0.05). Notwithstanding broader
questions as to the usefulness of frequentist statistical significance
as a concept, we do not report significance values here as this is a
simulation paper, and so statistical significance would have no real
meaning since the sample sizes available to the test are arbitrarily
chosen. See @white2014. Similarly, we do not account for statistical
issues such as spatio-temporal clustering of observations. The model
structures used here represent the core philosophy of the underlying
models. Real-world applications would need to be tailored to the local
context following general best-practices in modeling and causal
inference based on observational data from social-ecological systems xx
citation xx.

Given that all indicators are fit to positive continuous data, we assume
a log-normal distribution for all models. Given that we are not focused
on estimating error rates in this paper, for simplicity we omit error
terms and the distribution name from each model description, rather
following the simplified notation of

$$
observation_i \sim \beta_{MPA}x_i + \pmb{\beta_y}\pmb{y_i}
$$

Where *observation* is the dependent variables in question (e.g. biomass
density) for a given observation *i*, $\beta_{MPA}$ is the estimated
effect attributed to the MPA as measured by independent variable *X*,
and $\pmb{\beta_{y}}$ is a vector of coefficients associated with the
vector of additional independent variables $\pmb{Y}$ also included in
the model. All models include an intercept which is not notated and a
coefficient representing the total unfished biomass across all species
in a given patch, to serve as a proxy for controlling for observed
habitat differences.

#### Response Ratios

Response ratios are the ratio of some measure such as biomass density
inside an MPA relative to the value in a selected control site outside
the MPA. They have historically been the most commonly reported
indicator of MPA effects [e.g. @caselle2022; @caselle2015; @lester2009].

Response ratios are calculated as the difference in mean log biomass
density inside the MPA relative to outside, weighted by absolute
distance of sampled patches from the MPA border, such that the
comparison is weighted towards locations furthest inside the MPA
relative to sites furthest outside the MPA.

$$
log(biomass_i) \sim \beta_{MPA}MPA_i
$$

This is analogous to

$$
log \left(\frac{B_{protected}}{B_{reference}}  \right) = log(B_{protected}) - log(B_{reference})
$$

We calculate a length-based response ratio which operates the same as
the biomass response ratio but measure mean length inside versus outside
rather than biomass.

$$
log(L) \sim N(MPA,\sigma)
$$

@lester2009

#### Gradients

#### Before-After Control-Impact

Inside versus outside and gradient based

Response ratios require data from both outside and inside of an MPA. If
an MPA is truly no-take, as simulated here, this presents a problem, as
the only way to get data from inside would be a fishery-independent
monitoring program, which many communities may not have funds to
support, particularly at large spatial scales.

Gradients are an alternative form of indicator that gets around this
challenge by attempting to measure some form of "spillover" from MPAs
and attributing that spillover as an index of MPA performance. For
example, @halpern2009 examined how biomass densities (right?XX) changed
with distance from MPA borders across a range of case studies.
@medoff2022 and @lynham2024 measured CPUE of tropical tunas close to and
far from the border of a large MPA. "Fishing-the-line" [@kellner2007],
or increased fishing effort in the water around an MPA relative to far,
has also been measured XX citations here, actually hard to find in lit?
XX

While appealing, gradients do present some empirical challenges. For
example the "slope" coefficient of a model measuring CPUE as a function
of distance will depend on the units of distance in the model, so
outside of "is significantly different than zero", it is challenging to
develop a standardized effect size. @halpern2009 solved this by assuming
that biomass would go to zero in the absence of an MPA, but this is
rarely (ever) the case xx.

While many functional forms for measuring spillover gradients have been
proposed, they all are based on the basic premise that there should be a
difference in the metric in question near the MPA relative to far from
the MPA. Similar to @lynham2024 We use a generalized form of a gradient
model then that breaks patches outside of the MPA into two categories of
"near" (top 20th percentile of linear distance to an MPA) and "far"
(bottom 20th percentile of patches by linear distance to an MPA), and
then measure the difference in the outcome in question in the near
relative to the far

$$
log(outcome) \sim N(NEAR,\sigma)
$$

@methratta2020

@halpern2009

@medoff2022

"The expectation that spillover from marine reserves will produce
abundance gradients with distance from the reserve, with a shape that
depends on species mobility and catch rates, was first described over a
decade ago (Rakitin & Kramer 1996) and later refined and modelled
(Kaunda-Arara & Rose 2004; Goni et al. 2006)." [@halpern2009]

@halpern2009 defined two metrics for estimating spillover distance; the
distance at which biomass density was 5% of the maximum observed biomass
density inside or outside of the MPA, and the distance at which biomass
density was 5% of the range, where range is calculated as the average of
the two points furthest from the reserve border and the two points
furthest inside the reserve, after fitting a smoother to the density as
a function of distance relationship

However, this method makes the assumption that biomass density goes to 0
at some distance from the reserve.

### BACI and BAG

Indicator programs will often only have access to data post-MPA
implementation, interpreting inside vs. outside or near vs. far as their
control and impact groups, but lacking the before and after. This is a
well known problem because without before and after data it is harder to
control for pre-treatment differences in values, or to account for
exogenous changes in the outcome in question (e.g. environmental
shocks).

BACI and BAG two common solutions to this, so we include those as well,
of the general form, where $after \times MPA$ is assumed to be the
effect of the MPA, conditional on the BACI assumptions, most notably the
parallel trends and stable unit treatment variable assumptions
(citation)

$$
log(outcome) \sim N(after + MPA + after \times MPA, \sigma)
$$

### A note on Significance

Empirical indicators are often evaluated to some degree based on their
statistical significance (e.g. p \< 0.05). Notwithstanding broader
questions as to the usefulness of frequentist statistical significance
as a concept, we do not report significance values here as this is a
simulation paper, and so statistical significance would have no real
meaning since the sample size available to the test are arbitrarily
chosen. See @white2014. Similarly, we do not account for issues such as
spatio-temporal clustering of observations, which would affect estimates
of variability and as such significance. However, all of these issues
would need to be addressed in real empirical settings not fit to
simulated data. The model structures used here represent the core
philosophy of the underlying models, but real-world applications would
need to augment these to address statistical smapling issues as needed
xx.

## Results

### Case Study

```{r}
#|label: case-study
#|cache: true


# set.seed(1234321)
set.seed(42)

difficulties <- c("complex")
n_states <- 1
difficulty_species <- list(
  complex = c(
    "lutjanus malabaricus",
    "pristipomoides filamentosus",
    "epinephelus fuscoguttatus",
    "carcharhinus amblyrhynchos"
  )
)

difficulty <- "complex"

baseline_state_experiments <-
  tibble(
    kiss = sample(c(FALSE), n_states, replace = TRUE),
    mpa_response = sample(c("stay", "leave"), n_states, replace = TRUE),
    habitat_patchiness = runif(n_states, 1e-3, .01),
    max_abs_cor = runif(n_states, 1e-3, .9),
    spatial_q = sample(
      c(FALSE, FALSE),
      n_states,
      replace = TRUE,
      prob = c(1, 3)
    ),
    spatial_allocation = sample(c("ppue", "rpue", "revenue"), n_states, replace = TRUE),
    fleet_model = sample(c("open_access"), n_states, replace = TRUE)
  ) %>%
  mutate(state_id = 1:nrow(.))

port_locations <-
  tibble(x = c(1, resolution[1]), y = c(1, resolution[2])) # coordinates to test impact of highly disparate ports


critters <-
  tibble(scientific_name = difficulty_species[[difficulty]])
message("creating habitats")

state_experiments <- baseline_state_experiments %>%
  mutate(
    habitats = future_pmap(
      list(kp = habitat_patchiness, max_abs_cor = max_abs_cor),
      sim_habitat,
      critters = critters$scientific_name,
      resolution = resolution,
      patch_area = patch_area,
      .progress = TRUE,
      .options = furrr_options(seed = TRUE)
    )
  ) %>%
  mutate(critter_correlations = map(habitats, ~ process_correlations(.x$critter_correlations))) |>
  unnest(cols = critter_correlations) |>
  mutate(habitats = map(
    habitats,
    ~ .x$critter_distributions  |> select(-patch) |> group_by(critter) |> nest(.key = "habitat")
  )) |>
  unnest(cols = habitats) %>%
  ungroup() |>
  mutate(
    seasonal_movement = sample(c(FALSE, TRUE), length(state_id), replace = TRUE),
    spawning_aggregation = sample(c(TRUE, FALSE), length(state_id), replace = TRUE),
    spawning_season = sample(1:seasons, length(state_id), replace = TRUE),
    f_v_m = runif(length(state_id), 0.01, 0.24),
    adult_home_range = sample(c(2.5, 25), length(state_id), replace = TRUE),
    recruit_home_range = sample(c(2.5, 25), length(state_id), replace = TRUE),
    steepness = runif(length(state_id), min = 0.6, max = 1),
    b0 = rlnorm(length(state_id), log(100 * patches), 0.6),
    hyperallometry = sample(c(1, 2), length(state_id), replace = TRUE),
    sigma_rec = sample(c(0.666), length(state_id), replace = TRUE),
    density_dependence = sample(
      c(
        "global_habitat",
        "local_habitat",
        "pre_dispersal",
        "post_dispersal"
      ),
      length(state_id),
      replace = TRUE
    )
  ) %>%
  mutate(
    spawning_season = ifelse(spawning_aggregation, NA, NA),
    ontogenetic_shift = sample(c(TRUE, FALSE), length(state_id), replace = TRUE)
  ) |>
  mutate(ontogenetic_shift = ifelse(kiss, FALSE, ontogenetic_shift)) |>
  mutate(density_dependence = ifelse(ontogenetic_shift, "local_habitat", density_dependence))

state_experiments$b0 <- ifelse(
  str_detect(
    state_experiments$critter,
    ("carcharhinus|sphyrna|prionace")
  ),
  state_experiments$b0 / 10,
  state_experiments$b0
) # try and keep shark popsize on average smaller than others

message("finished habitats")


# state_experiments$b0 <- c(1000,1000,1000,1000)
message("creating critters")

state_experiments <- state_experiments %>%
  rename(scientific_name = critter) |>
  mutate(
    critter = future_pmap(
      list(
        sciname = scientific_name,
        habitat = habitat,
        seasonal_movement = seasonal_movement,
        spawning_aggregation = spawning_aggregation,
        spawning_season = spawning_season,
        f_v_m = f_v_m,
        adult_home_range = adult_home_range,
        recruit_home_range = recruit_home_range,
        density_dependence = density_dependence,
        hyper = hyperallometry,
        ontogenetic_shift = ontogenetic_shift,
        steepness = steepness,
        b0 = b0,
        kiss = kiss,
        sigma_rec = sigma_rec
      ),
      create_experiment_critters,
      resolution = resolution,
      seasons = seasons,
      .progress = TRUE,
      .options = furrr_options(seed = TRUE)
    )
  )

message("finished critters")


 # function to randomize selectivity parameters
  selfoo <- function(x,i){
    out <-   list(
      sel_start = runif(i, .05, 2),
      # proportion of length 50% mature at 50% selectivity
      sel_delta = runif(i, 1e-3, .25),
      # offset for 95% selectivity
      sel05_anchor = runif(i, 0, 0.9),
      sel_at_linf = runif(i, 0, 1)
    )
    
    out$sel05_anchor <- out$sel05_anchor * out$sel_start # must be smaller than length at 50% selectivity
    
    return(out)
    
  }
  state_experiments <- state_experiments %>%
    group_by(state_id) %>%
    nest() %>%
    mutate(
      fauna = map(data, ~ .x$critter %>% set_names(.x$scientific_name)),
      sels = map(fauna, ~ map2(1:2, length(.x), selfoo)),
      sel_form = map(fauna, ~ map2(1:2,length(.x), ~sample(c("uniform","logistic","double_normal"), .y, replace = TRUE))),
      prices = map(fauna, ~ map2(1:2, length(.x),~runif(.y, 1, 10))),
      use_ports = map(fauna,~sample(c(TRUE,FALSE), 2, replace = TRUE))
    ) |> 
    ungroup()
  # state_experiments$fauna[[1]]$`lutjanus malabaricus`$diffusion_foundation[[1]] |> image()
  
  # state_experiments$fauna[[1]]$`lutjanus malabaricus`$movement_matrix[[1]] |> image()
  
  # state_experiments$fauna[[1]][[4]]$b0
  # stop()
  state_experiments <- state_experiments %>%
    mutate(
      fleet = pmap(
        list(
          fauna = fauna,
          state = data,
          sels = sels,
          sel_form = sel_form,
          prices = prices,
          use_ports = use_ports
        ),
        create_fleets,
        difficulty = difficulty,
        port_locations = port_locations,
        resolution = resolution,
        .progress = "making fleets"
      )
    )

      # prepare recruitment deviate generator
    state_experiments <- state_experiments |>
      mutate(
        max_abs_cor_rec = sample(c(0, .66), n(), replace = TRUE),
        rec_dev_cov_and_cor = map2(fauna, max_abs_cor_rec, create_rec_dev_cov_and_cor)
      )
    
  
# add in starting conditions
init_condit <- function(fauna, fleets, rec_dev_cov_and_cor, years = 125) {
  starting_trajectory <-
    simmar(fauna = fauna,
           fleets = fleets,
           years = years,
           cor_rec = rec_dev_cov_and_cor$cor)
  
  # plot_marlin(check)
  
  starting_conditions <-
    starting_trajectory[(length(starting_trajectory) - seasons + 1):length(starting_trajectory)]
  # starting_trajectory[1:length(starting_trajectory)]
  
  proc_starting_conditions <-
    process_marlin(starting_conditions, keep_age = FALSE)
  
  out <- list(starting_conditions = starting_conditions,
              proc_starting_conditions = proc_starting_conditions)
  
}

message(glue::glue("simulating initial {difficulty} conditions"))
state_experiments <- state_experiments %>%
  mutate(tmp = future_pmap(
    list(fauna = fauna,
         fleet = fleet,
         rec_dev_cov_and_cor = rec_dev_cov_and_cor),
    init_condit,
    .progress = TRUE,
    .options = furrr_options(seed = TRUE)
  ))
message(glue::glue("finished simulating initial {difficulty} conditions"))

state_experiments$starting_conditions <-
  map(state_experiments$tmp, "starting_conditions")

state_experiments$proc_starting_conditions <-
  map(state_experiments$tmp, "proc_starting_conditions")

state_experiments <- state_experiments %>%
  select(-tmp)

cs_state_depletions <-
  map_df(state_experiments$starting_conditions,
         ~ map_df(.x, ~ map_df(.x, ~ sum(.x$ssb_p_a) / .x$ssb0)),
         .id = "state_id") |>
  pivot_longer(-state_id, names_to = "critter", values_to = "step_depletion") |>
  group_by(state_id, critter) |>
  summarise(depletion = mean(step_depletion)) |>
  mutate(state_id = as.integer(state_id))

state_experiments <- state_experiments |>
  left_join(cs_state_depletions |> group_by(state_id) |> nest(.key = "depletion"),
            by = "state_id")


state_experiments <- state_experiments |> 
  mutate(log_rec_devs = map2(fauna, rec_dev_cov_and_cor, generate_rec_devs, years = mpa_years))

# generate placement experiments

placement_experiments <- expand_grid(
  placement_strategy = c("target_fishing"),
  prop_mpa = c(0,0.3),
  mosaic = FALSE,
  critters_considered = seq(
    length(state_experiments$fauna[[1]]),
    length(state_experiments$fauna[[1]]),
    by = 1
  ),
  placement_error = c(0)
) %>%
  group_by_at(colnames(.)[!colnames(.) %in% c("temp", "prop_mpa")]) %>%
  nest() %>%
  ungroup() %>%
  mutate(placement_id = 1:n(),
         sigh = vector(mode = "list", length = n())) %>%
  unnest(cols = data)

for (p in 1:nrow(placement_experiments)){

placement_experiments$sigh[[p]] <- state_experiments |>
  ungroup() %>%
  mutate(
    results = future_pmap(
      list(
        starting_conditions = starting_conditions,
        proc_starting_conditions = proc_starting_conditions,
        fauna = fauna,
        fleets = fleet,
        log_rec_devs = log_rec_devs
      ),
      run_mpa_experiment,
      placement_strategy = placement_experiments$placement_strategy[p],
      prop_mpa = placement_experiments$prop_mpa[p],
      mosaic = placement_experiments$mosaic[p],
      critters_considered = placement_experiments$critters_considered[p],
      placement_error = placement_experiments$placement_error[p],
      resolution = resolution,
      patch_area = patch_area,
      drop_patches = FALSE,
      steps_to_keep = "all",
      years = mpa_years,
      mpa_offset = 10,
      keep_age = TRUE,
      .options = furrr_options(seed = TRUE)
    )
  )

}

# quick and dirty comparision vs. benchmark
fauna_results <- placement_experiments$sigh[[2]]$results[[1]]$results$fauna |> 
  mutate(prop_mpa = placement_experiments$prop_mpa[2] ) |> 
    mutate(critter = critter_namer(critter))


fleet_results <-placement_experiments$sigh[[2]]$results[[1]]$results$fleet |> 
    mutate(prop_mpa = placement_experiments$prop_mpa[2] ) |> 
    mutate(critter = critter_namer(critter))




benchmark_fauna_results <- placement_experiments$sigh[[1]]$results[[1]]$results$fauna |> 
    mutate(prop_mpa = placement_experiments$prop_mpa[1] ) |> 
    mutate(critter = critter_namer(critter))



benchmark_fleet_results <-placement_experiments$sigh[[1]]$results[[1]]$results$fleet |> 
    mutate(prop_mpa = placement_experiments$prop_mpa[1] ) |> 
    mutate(critter = critter_namer(critter))




mpa_step <- min(fauna_results$year) + 10 - 2

# state_experiments$fleet[[1]]$alpha$metiers[[4]]$sel_at_length |> 
#   plot()
# 



```

@fig-case-study provides an illustration of the kinds of MPA scenarios
included in this analysis. This selected scenario is from the "complex"
set, meaning that there are four different species targeted by two
different fishing fleets. Each species has a different baseline species
distribution ({@fig-case-study}-A), and each fleet has their own
relative prioritization of species and port locations. In one scenario a
contiguous MPA is placed covering the 30% of the simulated seascape
where the highest biomass of fish is caught, redistributing fishing
effort ({@fig-case-study}-B). The total biomass by species
({@fig-case-study}-C), and catch by species and fleet
({@fig-case-study}-D), are calcualted over time, and compared between
the state of the world with the MPA (solid lines) relative to the world
without the MPA (dashed lines). Values from the simulated world with the
MPA would be used to calculate relevant indicators such as response
ratios.

```{r}
#| label: fig-case-study
#| fig-cap: "Case study simulation. A) Distribution of biomass per species in space, with more darker colors indicating lower biomass. B) Distribution of fishing effort, with darker colors indicating lower fishing effort C) Evolution of biomass per species over time, with vertical line indicating year of 30% MPA implementation. D) Catch by species and fleet over time, with vertical line indicating year of 30% MPA implementation. For panels C and D, solid line indicates world with MPA, dashed line simulated counter-factual where MPAs are not implemented."

# stop("AHHHHH, RUNAWAY SHARKS!")

mpa <- fauna_results |> 
  filter(step == max(step)) |> 
  group_by(x,y) |> 
  summarise(mpa = unique(mpa))
  
  
alpha <- benchmark_fauna_results |> 
  filter(step == max(step)) |> 
  group_by(critter, x,y) |> 
  summarise(b = sum(b)) |> 
  group_by(critter) |> 
  mutate(sb = b / max(b)) |> 
  ungroup() |> 
  left_join(mpa, by = c("x","y")) |> 
  ggplot(aes(x,y,fill =sb)) + 
  geom_tile(show.legend = FALSE) + 
  facet_wrap(~critter) + 
  scale_fill_viridis_c() + 
  scale_x_continuous(name = "Longitude",expand = c(0,0)) + 
  scale_y_continuous(name = "Latitude",expand = c(0,0)) +
  labs(subtitle = "A) Biomass Distribution Without MPA") +
  theme(axis.text = element_blank())


beta <- fleet_results |> 
  filter(step == max(step)) |> 
  group_by(fleet, x,y, mpa) |> 
  summarise(effort = unique(effort)) |> 
  group_by(fleet) |> 
  mutate(se = effort / max(effort)) |> 
  ggplot(aes(x,y,fill =se, color = mpa)) + 
  geom_tile(show.legend = FALSE) + 
  facet_wrap(~fleet) + 
  scale_fill_viridis_c(option = "plasma") + 
  scale_x_continuous(name = "Longitude",expand = c(0,0)) + 
  scale_y_continuous(name = "Latitude",expand = c(0,0)) +
  labs(subtitle = "B) Effort Distribution") +
  theme(axis.text = element_blank())

fauna_experiment <- fauna_results |> 
  bind_rows(benchmark_fauna_results)


fleet_experiment <- fleet_results |> 
  bind_rows(benchmark_fleet_results)

delta <- fauna_experiment |> 
  mutate(experiment = if_else(prop_mpa == 0, "Without MPA", "With MPA")) |> 
  group_by(critter, step, prop_mpa, experiment) |> 
  summarise(biomass = sum(b, na.rm = TRUE)) |> 
  ggplot(aes(step, biomass, color = critter, linetype = experiment)) + 
    geom_vline(xintercept = mpa_step) +
  geom_line() + 
  scale_linetype(name = "World...") + 
  guides(color = guide_legend(nrow = 2)) + 
  labs(subtitle = "C) Biomass per species over time")



kappa <- fleet_experiment |> 
  mutate(experiment = if_else(prop_mpa == 0, "Without MPA", "With MPA")) |> 
  group_by(critter, step, prop_mpa, experiment, fleet) |> 
  summarise(catch = sum(catch, na.rm = TRUE)) |> 
  ggplot(aes(step, catch, color = critter, linetype = experiment)) + 
  geom_vline(xintercept = mpa_step) +
  geom_line() + 
  scale_linetype(name = "World...") + 
  facet_wrap(~fleet) + 
  guides(color = guide_legend(nrow = 2)) +
  labs(subtitle = "D) Catch per species per fleet over time")


# fleet_experiment |> 
#   group_by(fleet, step) |> 
#   summarise(effort = sum(effort)) |> 
#   ggplot(aes(step, effort, color = fleet)) + 
#   geom_line()

# kappa <- fleet_results |> 
#   group_by(step, critter, fleet) |> 
#   summarise(catch = sum(catch, na.rm = TRUE)) |> 
#   ggplot(aes(step, catch, fill = critter)) +
#   geom_area() + 
#   geom_vline(xintercept = mpa_step) +
#   facet_wrap(~fleet, labeller = label_both) + 
#   scale_fill_brewer(name = "", palette = "Set1") +
#   theme(legend.position = "bottom") +
#   scale_y_continuous(name = "Catch", limits = c(0,NA)) + 
#   scale_x_continuous(name = "Time Step") +
#   guides(fill = guide_legend(nrow = 1)) + 
#   labs(subtitle = "C) Catch by fleet over time")
# 
# 
# delta <- fauna_results |> 
#   group_by(step, critter) |> 
#   summarise(biomass = sum(b, na.rm = TRUE)) |> 
#   ggplot(aes(step, biomass, color = critter)) +
#   geom_line(show.legend = FALSE) + 
#   geom_vline(xintercept = mpa_step) +
#   scale_color_brewer(name = "", palette = "Set1") +
#   theme(legend.position = "bottom") +
#   scale_y_continuous(name = "Biomass", limits = c(0, NA)) + 
#   scale_x_continuous(name = "Time Step") +
#   guides(color = guide_legend(nrow = 1)) + 
#   labs(subtitle = "C) Biomass per species over time")

fig <- ((alpha + beta) / (delta + kappa) + plot_layout(guides = "collect") & theme(legend.position = "bottom"))


figsaver(fig)


```

### How Variable are MPA Effects?

<!-- Note that for all of these results we cannot really assign a probability to any one state of nature, and so should focus more on the range and trends in outcomes rather than the shapshots of outcome density.  -->

Our simulated MPAs had a wide range of effects on biomass and catch,
with both positive and negative causal effects possible for all measured
outcomes @fig-outcomes. MPAs almost always (\>XX% of simulations) caused
an increase in *Biomass Inside* their borders, though negative effects
were also possible. Simulated MPA effects on biomass outside the reserve
were almost perfectly split between positive and negative effects. The
effects on *Total Biomass* (inside and outside) reflect this balance
between *Inside* and *Outside* as having generally positive effects but
to a lesser degree than *Biomass Inside*. Negative catch outcomes were
slightly more frequent than positive catch outcomes. Increasing the
complexity of the simulation space (from the *simple* single species
single fleet to the *complex* multi-species multi-fleet) generally acted
to increase the variance in outcomes across the metric in question, with
both higher positive effects and greater negative effects possible.

That MPAs can have negative effects on catch is intuitive, as the
asymptotic effect of MPA size (closing 100% of the ocean) has to be a
100% loss in catch, and therefore even for scenarios where *some* MPA
size could increase catch the effects of closures on catch has to become
negative at some point once the MPA size becomes large enough. Our
result that MPA can have a negative effect on total biomass outside,
inside, and in total is less intuitive. This unintended consequence
occurs in our model due to fleet dynamics. MPA can reduce biomass
outside their borders by concentrating effort in the remaining fishing
grounds to a level that cannot be compensated for by spillover from the
MPA. Beyond this, if an MPA results in displacement of a fishing fleet
from a relatively low biomass area for a given species to a high biomass
area for that species, the net result can be net increase in the total
fishing mortality on that species, and as a result a net decrease in the
total biomass of that species, potentially both inside and outside the
MPA since fish move across the borders. These negative effects on
*Total* or *Inside* biomass were relatively rare, but are possible when
species have heterogeneous and in cases negatively correlated
distributions, and have heterogeneous vulnerability to different fishing
fleets.

xx make SI version broken up by depletion level not difficulty

```{r}
#| label: fig-outcomes
#| fig-cap: Distribution of simulation outcomes across metrics (columns), proportion of seascape in MPA (rows), and scenario complexity (colors). Y-axis shows the percent change in the outcome in question caused by the MPA. Biomass Inside refers to total biomass of individual species inside MPA borders. Biomass Outside refers to total biomass of individual species outside MPA borders. Total Biomass refers to total biomass of individual species inside and outside MPA borders. Catch refers to catch per species and fleet outside the MPA. 

outcome_labeller <- c(
  fished_biomass = "Biomass Outside",
  mpa_biomass = "Biomass Inside",
  biomass = "Total Biomass",
  catch = "Catch"
)

  sighbreaks <- seq(-1,2, by = .5)
  sighlabs <- paste0(sighbreaks * 100, "%")
  sighlabs[length(sighlabs)] <- "≥200%"

fig <- mpa_outcomes |>
  filter(observation_error == default_observation_error) |>
  select(depletion,
         numeric_prop_mpa,
         difficulty,
         fished_biomass,
         mpa_biomass,
         biomass,
         catch) |>
  pivot_longer(-(depletion:difficulty)) |>
  mutate(mpa_bin = cut(numeric_prop_mpa, breaks = c(0, 0.15, 0.3, 6)),
         name = fct_relevel(name, "mpa_biomass","fished_biomass", "biomass"),
         difficulty = fct_relevel(difficulty,"simple", "medium")) |>
          mutate(mpa_bin = as_factor(case_when(mpa_bin == "(0,0.15]" ~ "0-15%", mpa_bin =="(0.15,0.3]" ~ "15-30%", .default = "30-60%"))) |>
    # filter(numeric_prop_mpa < 0.66, numeric_prop_mpa > 0.1) |> 
  ggplot(aes(x = difficulty, y = value)) +
  geom_hline(yintercept = 0, linetype = 2) +
  stat_interval(aes(color_ramp = after_stat(level),color = difficulty), .width = c(0.5,0.8,1)) +
  # stat_interval(aes(difficulty, value)) +
  # geom_density(aes(value, after_stat(scaled),fill = difficulty, color = difficulty),alpha = 0.25) +
  facet_grid(mpa_bin ~ name, scales = "free_y", labeller = labeller(name = outcome_labeller)) + 
  scale_x_discrete(name = '') +
  scale_y_continuous(name= "MPA Effect",limits = c(NA,2), oob = squish, breaks = sighbreaks, labels = sighlabs) +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 12, angle = 45, hjust = 1, vjust = 1),
        axis.text.y = element_text(size = 8),
        panel.spacing.x = unit(2, "lines")) + 
  ggdist::scale_colour_ramp_discrete(name = "Quantile Range", labels = c("100%","80%", "50%")) + 
  guides(color = "none")

 
figsaver(fig)

```

xx move to methods

Along with outcome-specific effects, our model allows us to examine
joint effects on biomass and catch. We broke our simulated outcomes into
quadrants defined by *unaffected* (effect size less than \|5%\|),
*positive* (effect size greater than 5%) and *negative* (effect size
less than -5%), assigned the change in total catch and total biomass per
species and fleet in each simulation to their appropriate quadrant, and
then calculated the frequency of factorial combinations of each quadrant
for each metric (@fig-quadrant-freq).

XX

At MPA sizes between 0-15% of the seascape the most common result was
*catch:unaffected & biomass:unaffected*, following by *catch:negative &
biomass:unaffected*. Increasing MPA size largely resulted in a decrease
in the percent of simulations under *catch:unaffected &
biomass:unaffected* and an increase in *catch:negative &
biomass:positive* (\>30% of simulations with MPA sizes between 30-60% of
the seascape xx)*.* The "win-win" quadrant of *catch:positive &
biomass:positive* was consistently the 4th most common outcome,
representing up to 15% of simulations with MPA sizes between 30-60% of
the seascape (@fig-quadrant-freq).

```{r}
#| label: fig-quadrant-freq
#| fig-cap: Frequency of different outcomes as a function of MPA size (panels)


fig <- quadrant_outcomes |>
  mutate(prop_mpa = as.numeric(as.character(prop_mpa)),
         observation_error == default_observation_error) |>
  filter(prop_mpa <= 0.6) |>
  mutate(size_bin = cut(prop_mpa, breaks = c(0, 0.15, 0.3, 6))) |>
  group_by(quadrant, size_bin) |>
  count() |>
  group_by(size_bin) |>
  mutate(pn = n / sum(n)) |>
  mutate(size_bin = as_factor(case_when(size_bin == "(0,0.15]" ~ "0-15%", size_bin =="(0.15,0.3]" ~ "15-30%", .default = "30-60%"))) |>
  ggplot(aes(reorder(quadrant, pn), pn)) +
  geom_col(position = "dodge") +
  coord_flip() +
  facet_wrap( ~ size_bin) +
  scale_x_discrete(name = "") + 
  scale_y_continuous(name = "Percent of Simulations", labels = scales::percent)

figsaver(fig)



```

### How Detectable are MPA Effects?

Our simulation results show that MPA effects can be highly variable in
both their direction and magnitude, and as such cannot be reliably
predicted *a priori* based solely on say MPA size. As a result, it is
important to be able to empirically measure effects of MPAs on biomass
and catch

The indicators evaluated in this paper had a range of correlations with
the causal effects of MPAs. The strongest positive correlation was ...
The strongest negative correlation was... Indicators X,Y,X had
effectively zero correlation with outcomes A,B,C. Strength of
correlation (and subsequent pseudo-R2) generally decreased with model
complexity.

xx explain value in correlations, RMSE, and ME individually xx

Indicator X had the lowest RMSE and bias, relationship to correlation...

xx color code text by whether it's a direct or implicit indicators?

```{r}
#| eval: true
#| label: fig-rho-error-bias
#| fig-cap: "test"
#| fig-height: 7

mape_meep_rho <- comparison |> 
  filter(!is.na(percent_mpa_effect) & !is.na(indicator_value),
         !str_detect(indicator, "cpue"),
         !str_detect(indicator, "catch")) |> 
  group_by(difficulty,name, indicator) |> 
  nest() |> 
  mutate(error = map(data, \(x) rmse_vec(x$percent_mpa_effect, x$indicator_value)),
         bias = map(data, \(x) mean(x$indicator_value - x$percent_mpa_effect)),
         rho = map(data, \(x) correlate(x$indicator_value, x$percent_mpa_effect, method = "spearman", quiet = TRUE)),
          indicator = str_remove_all(indicator, "ind_")) |> 
  unnest(cols = c(error,bias, rho)) |> 
  rename(rho = x) |> 
  ungroup() |> 
  mutate(
      name = fct_recode(
      name,
      "Biomass Outside" = "fished_biomass",
      "Biomass Inside" = "mpa_biomass",
      "Total Biomass" = "biomass",
      "Catch" = "catch"),
      indicator = fct_recode(
      indicator,
      "Biomass Density BACI" = "biomass_baci",
      "Mean Length Response Ratio" = "length_rr",
      "Biomass Density Response Ratio" = "biomass_rr",
      "Effort Gradient" = "effort_gradient",
      "Biomass Density Gradient BACI" = "biomass_bag",
      "Biomass Density Gradient" = "biomass_gradient")
  ) |> 
    mutate(name = fct_relevel(name, "Biomass Inside","Biomass Outside"  ,"Total Biomass"))

 
 
a <- mape_meep_rho |> 
  ggplot() + 
  geom_tile(aes(name, reorder(indicator, abs(rho)), fill = rho), color = "black") + 
  geom_text(aes(name, reorder(indicator, abs(rho)), label = round(rho^2,2))) +
  facet_wrap(~fct_rev(difficulty)) + 
  scale_fill_gradient2(name = "Correlation between Indicator and Outcome",limits = c(-1,1),
                       low = "tomato", high = "steelblue", mid = "white",
                       guide = guide_colorbar(frame.colour = "black",ticks.colour = "black", theme = theme(legend.key.width  = unit(8, "lines"),
  legend.key.height = unit(1, "lines")),
  direction = "horizontal",
  title.position = "left",
  title.vjust = 0.75)) + 
  scale_x_discrete(expand = c(0,0), position ="bottom", name = '') + 
  scale_y_discrete(expand = c(0,0), name = '') + 
  theme(legend.position = "top",
        axis.text.x = element_text(angle = 35, vjust = 1, hjust = 1)) + 
    labs(caption = "Text shows psuedo-R<sup>2</sup>", title = "A") +
  theme(plot.caption = element_textbox())



b <- mape_meep_rho |> 
  ggplot() + 
  geom_tile(aes(name, reorder(indicator, (rho)), fill = error), color = "black") + 
  ggtext::geom_richtext(aes(name, reorder(indicator, (rho)), label = round(100 * bias,0)), size = 3, alpha = 0.75,color = "black") +
  facet_wrap(~fct_rev(difficulty)) + 
  scale_fill_viridis_c(name = "RMSE",option = "plasma",limits = c(0, NA),
                       guide = guide_colorbar(frame.colour = "black",ticks.colour = "black", theme = theme(legend.key.width  = unit(8, "lines"),
  legend.key.height = unit(1, "lines")),
  direction = "horizontal",
  title.position = "left",
  title.vjust = 0.75), labels = scales::percent) + 
  scale_x_discrete(expand = c(0,0), position ="bottom", name = '') + 
  scale_y_discrete(expand = c(0,0), name = '') + 
  theme(legend.position = "top",
        axis.text.x = element_text(angle = 35, vjust = 1, hjust = 1)) + 
  labs(caption = "Text shows mean percentage-point bias (Indicator - Effect)", title = "B")

a / b + plot_layout(guides = "collect") & theme(legend.position = "top")

```

```{r}





```

fter data are often not available for MPA impact studies

@hopf2024

[@ban2019]. As such, we conducted a second test, limiting the candidate
indicators to only response ratios. In addition, we selected a set of
simulation results to match the distribution of response ratios observed
for targeted species in California MPAs (xx explain this, and add proper
name xx). We only selected simulation scenarios with MPA sizes between
10 and 40% of the seascape and depletion values between 0.2 and 0.8, to
roughly mirror potential conditions represented by the California MPAs

These scenarios help visualize the range of causal MPA effects that are
capable of producing the distribution of response ratios observed in the
selected California MPAs. Simulated response ratios were positively
correlated with *Biomass Inside*... explain the range of correlation
outcomes

(@fig-rr-performance).

```{r}
#| label: fig-rr-performance
#| fig-cap: "Simulated response ratios (x-axis) plotted against simulated MPA effects (y-axis), for subset of scenarios more reflective of the California MPA network. Simulations selected such that distribution of simulated response ratios roughly matches distribution of empirical response ratios for targeted finfish in California MPAs, reported in XX."

rr_performance <- comparison |>
    filter(observation_error == default_observation_error) |> 
  filter(str_detect(indicator, ("biomass_rr"))) |>
  mutate(combo = paste(name, indicator, sep = " ~ ")) |>
  mutate(combo = str_remove_all(combo, "ind_"))

rrs <- rr_performance |>
  filter(name %in% c("mpa_biomass","biomass", "catch", "fished_biomass"),
         between(prop_mpa,0.1,0.4),
         difficulty == "complex") |> 
    mutate(approx_rr = round(indicator_value / 0.1) * 0.1)


ca_rrs <- read_rds(here("data", "mpa_level_meta_results.Rds")) |> 
  filter(target_status == "Targeted") |> 
  janitor::clean_names() |> 
  as_tibble() |> 
  mutate(approx_rr = round(estimate / 0.1) * 0.1) 


sigh <- ca_rrs |> 
  left_join(rrs |> select(approx_rr, name, percent_mpa_effect, indicator_value, state_id),
            relationship = "many-to-many", by = "approx_rr") |> 
  left_join(state_depletions,relationship = "many-to-many",by = "state_id") |> 
  filter(!is.na(indicator_value)) |> 
  ungroup() |> 
  filter(between(depletion,0.2,0.8)) |> 
  group_by(name) |> 
  slice_sample(n = 200) |> 
  ungroup()

ca_indicator_performance <- sigh |>
  ungroup() |> 
  filter(is.finite(percent_mpa_effect), is.finite(indicator_value)) |>
  mutate(name = fct_relevel(name, "mpa_biomass","fished_biomass", "biomass", "catch"))


rr_cores <- ca_indicator_performance |> 
  group_by(name) |> 
  nest() |> 
  mutate(tmp = map(data, \(x) correlate(x$indicator_value, x$percent_mpa_effect, method = "spearman", quiet = TRUE))) |> 
  unnest(cols = tmp) |> 
  ungroup() 
 


# sigh |>
#   ggplot(aes(estimate)) +
#   geom_histogram(aes(estimate, fill = "observed"), bins = 20, alpha = 0.25) +
#   geom_histogram(aes(indicator_value, fill = "simulated"),bins = 20, alpha = 0.25) +
#   scale_x_continuous(breaks = seq(-2,5,by = 0.25) ) + 
#   facet_wrap(~name)

ca_rr_ind_plot <- sigh |>
  mutate(name = fct_relevel(name, "mpa_biomass","fished_biomass", "biomass", "catch")) |> 
  ggplot(aes(indicator_value, percent_mpa_effect)) +
  # geom_density_2d(alpha = 0.5, show.legend = FALSE) +
  # geom_bin_2d(color = "transparent", show.legend = FALSE, alpha = 0.5, bins = 10) +
    geom_point(aes(color = depletion), alpha = 0.75, size = 2) +
    geom_rug(sides = "br") +
  geom_hline(yintercept = 0,
             linetype = 2,
             color = "black") +
  geom_vline(xintercept = 0,
             linetype = 2,
             color = "black") +
      geom_richtext(data = rr_cores, aes(
    x = .75,
    y = 0.75,
    label = glue("&rho; = {round(x,2)}<br>psuedo-R² = {round(x^2,2)}")
  ),
  fill = NA, label.color = NA) +

  facet_wrap( ~ name, scales = "free_y", ncol = 2, labeller = labeller(name = outcome_labeller)) +
  scale_y_continuous(limits = c(NA, 1), oob = squish, name = "Simulated effect of MPA on..", labels = scales::percent) +
  scale_color_viridis_c(
    "BAU B/B0",
    limits = c(0, 1),
    option = "plasma",
    guide = guide_colorbar(
      frame.colour = "black",
      ticks.colour = "black",
      barwidth =  unit(11, "lines")
    )
  )  +  
  scale_x_continuous(limits = c(-.25,1.25), name = "Simulated Response Ratios (Biomass Inside / Biomass Outside - 1)") +
  theme(legend.position = "top")


figsaver(ca_rr_ind_plot)
```

## Discussion

That MPAs produce spillover is not really a question; animals move to
some degree, the question of interest then is how much, and we would
aregue that the sheer magnitude of spillover itself is not really of
interest, it is the net effect, in terms of conservatino or fishery
gains outside, and that is what these things do not tell us.

All else being equal, bigger conservation outcomes equal bigger ratios,
but bigger conservation outcomes mean lower fishing all else being equal

Why not CPUE?

There is a large body of "indicator" based empirical evidence from MPAs,
which can create an impression of clear empirical conclusions around
MPAs. For example, a 2018 NPR piece stated that

"The jury is in on marine reserves: They work. Research has repeatedly
shown that fish numbers quickly climb following well-enforced fishing
bans, creating tangible benefits for fishers who work the surrounding
waters. In fact, many experts believe fishing will only be sustainable
if marine reserves are expanded significantly." [@bland2018]

Simulating multiple species at a time is important because the same area
of ocean protected could correspond to very different percentages of
protection from the perspective of the population in question.

@hopf2024

@grace2024

Results are highly optimistic in terms of data quality: we assume no
observation error, and that a true index of unfished species
distribution are known to act as a control for habitat quality.

There are three problems, two statistical and one epistomological. For
indicators lacking a clear causal identification strategy, the core
problem is simply omitted variable bias (e.g. failing to control for
background trends in the outcome of interest). For indicators with a
causal identification strategy (e.g. BACI), the problem is SUTVA, i.e.
that what is labeled as a control is fact affected by the treatment.

However, even when these statistical problems are resolved, there
remains an epistimological problem, namely that what is measured, even
if it is being measuerd correctl, does not always map on to the outcome
of interest.

1.  MPAs are expanding. Despite this, lots of questions around what
    exactly we can expect from no-take MPAs

2.  Let's not overthink it: our simulations support the common-sense
    result that sufficiently sized and well-enforced no-take MPAs
    increase biomass inside their borders, often by a lot, though scale
    depending mostly on movement and fishing pressure. MPAs also
    generally have positive effects on total biomass, but not always,
    particularly because in 50% or more of simulations MPAs resulted in
    lower total biomass outside (but higher biomass in 50% as well).

3.  Catch outcomes largely mirrored distribution of biomass outside,
    with positive and negative outcomes about evenly split within MPA
    size bind and complexity.

4.  Why does this matter? These effects happen whether we measure them
    or not. But, effects are variable enough that measurement is useful
    (can't take effects for granted), for a few purpose. Given that
    negative impacts (catch, fished area, total biomass) are possible,
    if we weren't planning on them clearly want to measure outcomes to
    see if they happen and correct them if possible

5.  Even in the case of positive benefits, helpful to know "how
    positive", for example market-based programs, or to consider
    opportunity cost, or to adapt future management (how big does an MPA
    have to be to achieve X amount of conservation)

6.  Going to back to "let's not overthink it"; obvious that inside vs.
    outside is ripe for statistical problems. However, simulation
    testing says that it can be a perfectly fine, in fact good,
    indicator of the core purpose of an MPA: increase biomass inside the
    MPA.

7.  However, common indicators performed very badly as indicators of
    "outside" effects, either total biomass or catch. At extreme levels,
    they tended to be associated with positive conservation outcomes.
    However, in most cases almost no signal between indicator values
    degree of MPA effects. Runs contrary to conventional wisdom in
    papers of "clear response ratio is evidence for positive fishery
    effect". Seems to more often mean that the MPA was able to reduce
    fishing pressure so much that it resulted in a massive buildup
    inside but loss outside.

8.  So what? Link to @ban2019 . Case and empirics of MPAs often based on
    these indicators. We show that while these can be good indicators of
    "MPA was big enough to achieve positive effects inside", they are
    basically useless as indicators of outside processes

9.  @medoff2022 and @lynham2024 are two of the highest profile empirical
    MPA studies of the recent era. Both of these papers measured an
    indicator of MPA performance (CPUE near relative to far) for tunas,
    which then in the paper or in the press surrounding the paper made
    claims about outcomes. We explicitly test the performance of this
    type of gradient -based indicator, and find that it has almost no
    explanatory power as an indicator of biomass inside, outside, or
    both, or on total catch. As stated by @lynham2024, presence of a
    spillover benefit does not imply higher abundance or a more
    profitable fishery, but that message is quickly lost, as evidenced
    by the Editor's summary of @lynham2024 that states that "Such
    results clearly underline that MPAs are essential for protecting
    both species and fisheries", in direct contradiction of both
    @lynham2024 and the simulation results we show here, which is that
    indicators such as these don't provide reliable information on these
    broader-scale outcomes.

10. What do we suggest?

    1.  Shortening the game of telephone used around indicators. Results
        suggest that the indicators used here may indeed be useful for
        the original question of "did the MPA increase biomass inside",
        but have little signal for anything else

    2.  Development of a new set of data more closely tied to the actual
        outcomes in question (e.g. actual monitoring of economic
        performance)

    3.  Closer integration with the spatial stock assessment literature
        and world: if we want to make statements about effects of MPAs
        at population / fishery levels, then need to use the class of
        models that tracks things at that resolution @punt2023

### Caveats

Unbiased observation error is a little hard to say much about since
impact depends on sample size, which you can simulate away here. But,
tactical papers should think about what can actually be collected and
then simulate test based around actual sampling process

No complexities like layered fisheres management or external economic
shocks

Potential negative impacts are not unique to MPAs, a quota could also
have leakage into a non-quota species

### Discussion phrases parking lot

Acknolweding that negative effects are possible across all areas can
help reduce risk of a filedrawer effect

emphasize scale of response ratio axes: a response ratio value of 100%,
meaning that there being roughly 100% more biomass inside the reserve
than outside could have anything from a negative effect to a 300%
effect.

Coming years will see large increases in design and evaluation of MPAs.
Urgent need to design monitoring programs that are able to track
performance of relevant metrics so that we can learn appropiately, etc.

Results show that MPA performance is variable enough to warrant
investment in monitoring. Unintended consequences are possible, more
ways for positive conservation effects, but effect sizes are highly
variable holding MPA size constant, so important to measure how
effective if MPAs are being used to guide management.

What drives negative conservation effects when they do happen? One or
more of heterogeneous and negatively correlated habitat, effort
displacement, open access dynamics, and the "avoid fishing" placement
strategy. The last is interesting, as it under the most control of MPA
planners, and is certainly an outcome that can happen (place the MPAs in
marginal fishing grounds that are less likely to cause conflict).
Examples?

Heavy fishing correlated with positive catch outcomes, particularly in
simple scenarios, but not deterministic. Plenty of cases, particularly
under the more complex scenario, where catch goes down even when
overfishing present.

Depletion was generally most important important predictor of MPA
effects, followed by measures of the correlation across species, adult
movement, and sensitivity of the species to fishing (steepness). This is
interesting for a few reasons, namely that suggests that models that
don't take into account the ways that fleets interact with multiple
species across hetergenous habitats can miss the mark (ovando et al.
2024 in review). Also interesting that factors such as recruit diffusion
had very little importance?

Bioimass BACI / response ratio best predictors of MPA biomass, and both
performed reasonably well, though not perfect. Plenty of simulations,
particularly in more complex world, where MPA had a positive effect
inside the reserve but BACI showed no effect. But, outcomes were
correlated and very high BACI / response ratio values tended to
correspond to high effect sizes, even in cases where the core
assumptions of BACI / response ratio are violated. Compare effect sizes
to ratio values reported in lester et al.

Population effect messier. Little directional disagreement (very high
indicator, negative population effects, and negative effects associated
with lower indicator values. But, wide variability, with very high
indicator values corresponing with a very wide range of outcomes,
ranging from 0 to 400%. So, to some extent, doesn't tell you much more
than "had a positive effect", up until massive values. Massive values
might be an artifact of confined nature of simulation space though.

The story with catch is much worse. None of the evaluated indicators had
any meaningful ability on their own to predict catch outcomes. While
@medoff2022 did not claim a catch increase in their paper, media
coverage of said paper attributed higher CPUE near vs. far as a fishery
benefit, whereas these results show that there is no relationship
between the two, and indeed some bimodality where high values could
either correspond to a massive benefit or a near 100% loss in the
fishery (though that would presumably be noticed in the real world).

Ensemble shows possible to make some predictions in quadrants, but
highly uncertain. Goes back to basics of "simualted MPAs generally
improved biomass, but how much was highly variable, and no indicator
mapped onto catch".

Very important to note. This all assumes perfectly measured information.
Clearly, uncertain and/or biased sampling will make any relationships
between indicators and outcomes more uncertain. Further research needed
to consider reliability of indicators taking into account reasonable
observation error.

So what does this suggest for MPA monitoring going forward? Conditional
on quality of monitoring program always. Reality is often complicated,
conceptual model important in thinking through how real is real enough.
Results suggest that response ratio works best for MPA biomass, not bad
for population biomass but very imprecise, and absolutely terribly for
catch. No tested indicator was a reliable indicator of fishery outcomes.
So, current indicators may be suitable for "are we succeeding inside the
borders", could be used with caution for population level effects (no
guarantee, see @ovando2021), and should not be used as evidence for
fishery outcomes.

What does the future suggest? Better integration with spatial stock
assessment literature, linking process-based models to indicators rather
than pure statistical outcomes (e.g. leveraging basic life history in
terms of time to effects etc) @punt201 @nickols2019. Also, lots of
advances in spatial-temporal modeling @thorson2024a. At the same time,
collaborations with field biologists and the like critical to getting
the conceptual model right. Need better integration with social science
to figure out how do we effectively monitor socio-economic impacts.

Snappy concluding thing.

### 

high percent variability in catch at low exploitation since catch is
close to zero

Indicators worked best for MPA conservation, then biomass. Biomass was
uncertain, but positive was that generally speaking "high" indicator
values corresponded to "high" conservation outcomes. But, those are
really extreme values, map onto @lester2009. For smaller values, very
uncertain, range from negative to positive.

For catch, no indicator performed well.

Note that this is all assuming equilibrium! NPV is important too,
communities aren't happy if they go through 50 years of loss for
benefits in the 51st year @ovando2016

Just as a quota for one species can have unintended consequences on
another, so can MPAs.

Let us be clear. The simulation results presented here indicate that
clearly MPAs are capable of benefiting biomass and catch. However, they
are also capable of harming both.

We implement size limits all the time without needing complex causal
inference. Part of the reason for that is that it's a more direct lever,
but still. But, if the movement of the coming yeasr was "No Undersized
by 2035", resulting in a massive global investment in the design and
roll of out size limit programs, a deeper look at measuring the
performance of size limits might be warranted.

@halpern2004

@franceschini2024

@kay2012

@kellner2007

@ohayon2021

\newpage

## References

::: {#refs}
:::

# SI

```{r}

outcome_labeller <- c(
  fished_biomass = "Biomass Outside",
  mpa_biomass = "Biomass Inside",
  biomass = "Total Biomass",
  catch = "Catch"
)

sighbreaks <- seq(-1,2, by = .5)
sighlabs <- paste0(sighbreaks * 100, "%")
sighlabs[length(sighlabs)] <- "≥200%"

fig <- mpa_outcomes |>
  filter(observation_error == default_observation_error) |>
  select(depletion,
         numeric_prop_mpa,
         difficulty,
         fished_biomass,
         mpa_biomass,
         biomass,
         catch) |>
  pivot_longer(-(depletion:difficulty)) |>
  mutate(
    depletion_bin = cut(pmin(1.19,depletion), breaks = c(0 ,.25, 0.5,1.2)),
  mpa_bin = cut(numeric_prop_mpa, breaks = c(0, 0.15, 0.3, 6)),
         name = fct_relevel(name, "mpa_biomass","fished_biomass", "biomass"),
         difficulty = fct_relevel(difficulty,"simple", "medium")) |>
  mutate(mpa_bin = as_factor(case_when(mpa_bin == "(0,0.15]" ~ "0-15%", mpa_bin =="(0.15,0.3]" ~ "15-30%", .default = "30-60%"))) |>
   mutate(depletion_bin = as_factor(case_when(depletion_bin == "(0,0.25]" ~ "0-25%", depletion_bin =="(0.25,0.5]" ~ "25-50%", .default = ">50%"))) |>
  mutate(depletion_bin = fct_relevel(depletion_bin, "0-25%","25-50%" )) |> 
  # filter(numeric_prop_mpa < 0.66, numeric_prop_mpa > 0.1) |> 
  ggplot(aes(x = depletion_bin, y = value)) +
  geom_hline(yintercept = 0, linetype = 2) +
  stat_interval(aes(color_ramp = after_stat(level),color = depletion_bin), .width = c(0.5,0.8,1)) +
  # stat_interval(aes(difficulty, value)) +
  # geom_density(aes(value, after_stat(scaled),fill = difficulty, color = difficulty),alpha = 0.25) +
  facet_grid(mpa_bin ~ name, scales = "free_y", labeller = labeller(name = outcome_labeller)) + 
  scale_x_discrete(name = '') +
  scale_y_continuous(name= "MPA Effect",limits = c(NA,2), oob = squish, breaks = sighbreaks, labels = sighlabs) +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 12, angle = 45, hjust = 1, vjust = 1),
        axis.text.y = element_text(size = 8),
        panel.spacing.x = unit(2, "lines")) + 
  ggdist::scale_colour_ramp_discrete(name = "Quantile Range", labels = c("100%","80%", "50%")) + 
  guides(color = "none")


figsaver(fig)
```

```{r}
state_depletions |> 
  ggplot(aes(depletion, fill = critter)) + 
  geom_histogram() + 
  facet_grid(difficulty ~ critter)
```

```{r}
#| eval: true
#| fig-height: 8

total_mape_meep_rho <- total_comparison |> 
  filter(!is.na(percent_mpa_effect) & !is.na(indicator_value),
         !str_detect(indicator, "cpue"),
         !str_detect(indicator, "catch")) |> 
  group_by(difficulty,name, indicator) |> 
  nest() |> 
  mutate(error = map(data, \(x) rmse_vec(x$percent_mpa_effect, x$indicator_value)),
         bias = map(data, \(x) mean(x$indicator_value - x$percent_mpa_effect)),
         rho = map(data, \(x) correlate(x$indicator_value, x$percent_mpa_effect, method = "spearman", quiet = TRUE)),
          indicator = str_remove_all(indicator, "ind_")) |> 
  unnest(cols = c(error,bias, rho)) |> 
  rename(rho = x) |> 
  ungroup() |> 
  mutate(
      name = fct_recode(
      name,
      "Biomass Outside" = "fished_biomass",
      "Biomass Inside" = "mpa_biomass",
      "Total Biomass" = "biomass",
      "Catch" = "catch"),
      indicator = fct_recode(
      indicator,
      "Biomass Density BACI" = "biomass_baci",
      "Mean Length Response Ratio" = "length_rr",
      "Biomass Density Response Ratio" = "biomass_rr",
      "Effort Gradient" = "effort_gradient",
      "Biomass Density Gradient BACI" = "biomass_bag",
      "Biomass Density Gradient" = "biomass_gradient")
  ) |> 
    mutate(name = fct_relevel(name, "Biomass Inside","Biomass Outside"  ,"Total Biomass"))

 
 
a <- total_mape_meep_rho |> 
  ggplot() + 
  geom_tile(aes(name, reorder(indicator, abs(rho)), fill = rho), color = "black") + 
  geom_text(aes(name, reorder(indicator, abs(rho)), label = round(rho^2,2))) +
  facet_wrap(~fct_rev(difficulty)) + 
  scale_fill_gradient2(name = "Correlation between Indicator and Outcome",limits = c(-1,1),
                       low = "tomato", high = "steelblue", mid = "white",
                       guide = guide_colorbar(frame.colour = "black",ticks.colour = "black", theme = theme(legend.key.width  = unit(8, "lines"),
  legend.key.height = unit(1, "lines")),
  direction = "horizontal",
  title.position = "left",
  title.vjust = 0.75)) + 
  scale_x_discrete(expand = c(0,0), position ="bottom", name = '') + 
  scale_y_discrete(expand = c(0,0), name = '') + 
  theme(legend.position = "top",
        axis.text.x = element_text(angle = 35, vjust = 1, hjust = 1)) + 
    labs(caption = "Text shows psuedo-R<sup>2</sup>", title = "A") +
  theme(plot.caption = element_textbox())



b <- total_mape_meep_rho |> 
  ggplot() + 
  geom_tile(aes(name, reorder(indicator, (rho)), fill = error), color = "black") + 
  ggtext::geom_richtext(aes(name, reorder(indicator, (rho)), label = round(100 * bias,0)), size = 3, alpha = 0.75,color = "black") +
  facet_wrap(~fct_rev(difficulty)) + 
  scale_fill_viridis_c(name = "RMSE",option = "plasma",limits = c(0, NA),
                       guide = guide_colorbar(frame.colour = "black",ticks.colour = "black", theme = theme(legend.key.width  = unit(8, "lines"),
  legend.key.height = unit(1, "lines")),
  direction = "horizontal",
  title.position = "left",
  title.vjust = 0.75), labels = scales::percent) + 
  scale_x_discrete(expand = c(0,0), position ="bottom", name = '') + 
  scale_y_discrete(expand = c(0,0), name = '') + 
  theme(legend.position = "top",
        axis.text.x = element_text(angle = 35, vjust = 1, hjust = 1)) + 
  labs(caption = "Text shows mean percentage-point bias (Indicator - Effect)", title = "B")

a / b + plot_layout(guides = "collect") & theme(legend.position = "top")




```

```{r}
#| label: fig-total-rr-performance
#| fig-cap: "Simulated response ratios (x-axis) plotted against simulated MPA effects (y-axis), for subset of scenarios more reflective of the California MPA network. Simulations selected such that distribution of simulated response ratios roughly matches distribution of empirical response ratios for targeted finfish in California MPAs, reported in XX."

total_rr_performance <- total_comparison |>
    filter(observation_error == default_observation_error) |> 
  filter(str_detect(indicator, ("biomass_rr"))) |>
  mutate(combo = paste(name, indicator, sep = " ~ ")) |>
  mutate(combo = str_remove_all(combo, "ind_"))

total_rrs <- total_rr_performance |>
  filter(name %in% c("mpa_biomass","biomass", "catch", "fished_biomass"),
         between(prop_mpa,0.1,0.4),
         difficulty == "complex") |> 
    mutate(approx_rr = round(indicator_value / 0.1) * 0.1)


ca_rrs <- read_rds(here("data", "mpa_level_meta_results.Rds")) |> 
  filter(target_status == "Targeted") |> 
  janitor::clean_names() |> 
  as_tibble() |> 
  mutate(approx_rr = round(estimate / 0.1) * 0.1) 


sigh <- ca_rrs |> 
  left_join(total_rrs |> select(approx_rr, name, percent_mpa_effect, indicator_value, state_id),
            relationship = "many-to-many", by = "approx_rr") |> 
  left_join(state_depletions,relationship = "many-to-many",by = "state_id") |> 
  filter(!is.na(indicator_value)) |> 
  ungroup() |> 
  filter(between(depletion,0.2,0.8)) |> 
  group_by(name) |> 
  slice_sample(n = 200) |> 
  ungroup()

ca_indicator_performance <- sigh |>
  ungroup() |> 
  filter(is.finite(percent_mpa_effect), is.finite(indicator_value)) |>
  mutate(name = fct_relevel(name, "mpa_biomass","fished_biomass", "biomass", "catch"))


rr_cores <- ca_indicator_performance |> 
  group_by(name) |> 
  nest() |> 
  mutate(tmp = map(data, \(x) correlate(x$indicator_value, x$percent_mpa_effect, method = "spearman", quiet = TRUE))) |> 
  unnest(cols = tmp) |> 
  ungroup() 
 


# sigh |>
#   ggplot(aes(estimate)) +
#   geom_histogram(aes(estimate, fill = "observed"), bins = 20, alpha = 0.25) +
#   geom_histogram(aes(indicator_value, fill = "simulated"),bins = 20, alpha = 0.25) +
#   scale_x_continuous(breaks = seq(-2,5,by = 0.25) ) + 
#   facet_wrap(~name)

ca_rr_ind_plot <- sigh |>
  mutate(name = fct_relevel(name, "mpa_biomass","fished_biomass", "biomass", "catch")) |> 
  ggplot(aes(indicator_value, percent_mpa_effect)) +
  # geom_density_2d(alpha = 0.5, show.legend = FALSE) +
  # geom_bin_2d(color = "transparent", show.legend = FALSE, alpha = 0.5, bins = 10) +
    geom_point(aes(color = depletion), alpha = 0.75, size = 2) +
    geom_rug(sides = "br") +
  geom_hline(yintercept = 0,
             linetype = 2,
             color = "black") +
  geom_vline(xintercept = 0,
             linetype = 2,
             color = "black") +
      geom_richtext(data = rr_cores, aes(
    x = .25,
    y = 0.75,
    label = glue("&rho; = {round(x,2)}<br>psuedo-R² = {round(x^2,2)}")
  ),
  fill = NA, label.color = NA) +

  facet_wrap( ~ name, scales = "free_y", ncol = 2, labeller = labeller(name = outcome_labeller)) +
  scale_y_continuous(limits = c(NA, NA), oob = squish, name = "Simulated effect of MPA on..", labels = scales::percent) +
  scale_color_viridis_c(
    "BAU B/B0",
    limits = c(0, 1),
    option = "plasma",
    guide = guide_colorbar(
      frame.colour = "black",
      ticks.colour = "black",
      barwidth =  unit(11, "lines")
    )
  )  +  
  scale_x_continuous(limits = c(NA,NA), name = "Simulated Response Ratios (Biomass Inside / Biomass Outside - 1)") +
  theme(legend.position = "top")


figsaver(ca_rr_ind_plot)
```

# Scraps

MPAs are increasingly being looked to to achieve a range of objectives
around the world [@grorud-colvert2021], 30x30, etc.

A common thread across these objectives is that they are often hard to
measure directly, either due to logistics or problems of causal
inference. By logistics, mean the challenge of collecting representative
and high quality data on lots of species and fleets over space and time.
By causal inference, even if you do all that, if catch goes up or down
without a counterfactual hard to know if caused by MPA or something
else.

As a result, empirical evidence for MPAs often depends on evaluating
simplier indicators [@harford2021] that are interpreted as proxies for
broader harder to measure objectives. For example "response ratios"
measure attributes such as biomass densities inside MPAs relative to
selected "reference" sites outside MPAs, which in turn are then
interpreted as being indicative of MPA performance [@lester2009;
@caselle2022].

However, interpreting empirical indicators as evidence for causal
effects on broader processes can be challenging in social-ecological
systems [@ferraro2018]. Even a perfectly measured indicator may not
actually map onto the outcome in question. Violations of key assumptions
in common empirical strategies (SUTVA, parallel trends, etc) can bias
estimates.

To that end, this paper asks two questions:

1.  Are MPA outcomes variable enough to justify efforts to measure their
    performance?

2.  If so, which indicators are reliable measures of performance?

The first is important since if the effects of MPAs are sufficiently
consistent and predictable, there isn't really a need for careful
monitoring; if closing 30% of an area produces the same general
magnitude of conservation and food security benefits 99% of the time,
probably not worth spending time trying to track the 1% of surprises.

But, if MPA effects are variable, then we want to be able to measure
performance to inform management (e.g. is population increasing or
decreasing because of MPA), and offset trade offs (e.g. losses in food
or profit related to fishing).

So far, our results show that 1. MPA outcomes can be highly variable,
particulary for food security, and 2. empirical indicators commonly used
to track performance of MPAs are actually poor predictors of real
outcomes.

We suggest some solutions.

```{r}
#| eval: false

state_fishing <- inds_and_outs |> 
  select(state_id, difficulty, critter, f_v_m) |> 
  unique()

predictors <- quadrant_outcomes |> 
  left_join(state_fishing,by = join_by(state_id, critter, difficulty)) |> 
  left_join(state_depletions,by = join_by(state_id, critter, difficulty)) |> 
  select(quadrant, ends_with("raw"), state_id, f_v_m, depletion) |> 
  na.omit() |> 
  mutate(quadrant = as.factor(quadrant))

# create initial split
quadrant_split <- group_initial_split(predictors, group = state_id, prop = 0.5)

# design cross validation splits

training_split <- training(quadrant_split)

testing_split <- testing(quadrant_split)

# model_spec <-
#   rand_forest(mtry = tune(),
#               min_n = tune(),
#               trees = tune()) %>%
#   set_engine("ranger") %>%
#   set_mode("classification")


  
model_spec <-
  rand_forest(mtry = tune(),
              min_n = tune(),
              trees = 100) %>%
  set_engine("ranger") %>%
  set_mode("classification")

model_recipe <- recipe(quadrant ~ ., data = training_split) |> 
  step_rm(state_id,f_v_m, depletion) |> 
  step_smote(quadrant,over_ratio = 0.5) 

# |> 
#   prep()
# 
# d = bake(a, new_data = NULL) |> 
#   count(quadrant, name = "training")


model_recipe_f <- recipe(quadrant ~ ., data = training_split) |> 
  step_rm(state_id, depletion) |> 
  step_smote(quadrant,over_ratio = 0.5) 


model_recipe_dep <- recipe(quadrant ~ ., data = training_split) |> 
  step_rm(state_id, f_v_m) |> 
  step_smote(quadrant,over_ratio = 0.5)

model_f_only <- recipe(quadrant ~ ., data = training_split) |> 
  step_rm(starts_with("ind_"),depletion,state_id) |> 
  step_smote(quadrant,over_ratio = 0.5)
# 
# a = bake(prep(model_f_only), new_data = NULL)


model_workflow <- 
  workflow() %>% 
  add_model(model_spec) %>% 
  add_recipe(model_recipe)

model_workflow_f <- model_workflow |> 
  update_recipe(model_recipe_f)

model_workflow_dep <- model_workflow |> 
  update_recipe(model_recipe_dep)

model_workflow_fonly <- model_workflow |> 
  update_recipe(model_f_only)

if (tune_grids | !file.exists(file.path(results_dir,"tuned_quant_grid.rds"))){
  future::plan(future::multisession, workers = 8)
  
  tuned_quant_grid <-
    model_workflow %>%
    tune_grid(
      resamples = group_vfold_cv(training_split, group = state_id, v = 2),
      grid = 20,
      control = control_grid(save_pred = FALSE)
    )
  
  future::plan(future::sequential)


write_rds(tuned_quant_grid, file.path(results_dir,"tuned_quant_grid.rds"))
} else {
  
  tuned_quant_grid <- read_rds(file.path(results_dir,"tuned_quant_grid.rds"))
  
}

model_spec <-
  rand_forest(mtry = tune(),
              min_n = tune(),
              trees = 100) %>%
  set_engine("ranger", importance = "permutation") %>%
  set_mode("classification")


model_workflow <- 
  workflow() %>% 
  add_model(model_spec) %>% 
  add_recipe(model_recipe)


best_params <- tune::select_best(tuned_quant_grid, metric = "accuracy")

tuned_model_workflow <- model_workflow |> 
  finalize_workflow(best_params)

tuned_model_workflow_f <- model_workflow_f |> 
  update_model(model_spec) |> 
  finalize_workflow(best_params)

tuned_model_workflow_dep <- model_workflow_dep |> 
    update_model(model_spec) |> 
  finalize_workflow(best_params)


tuned_model_workflow_fonly <- model_workflow_fonly |>
  update_model(model_spec) |>
  finalize_workflow(best_params)

fits <- list()
fits$tuned_fit <- parsnip::fit(tuned_model_workflow, training_split)

fits$tuned_fit_f <- parsnip::fit(tuned_model_workflow_f, training_split)

fits$tuned_fit_dep <- parsnip::fit(tuned_model_workflow_dep, training_split)

fits$tuned_fit_fonly <- parsnip::fit(tuned_model_workflow_fonly, training_split)

quadrant_vip_plot <- fits$tuned_fit %>% 
  extract_fit_parsnip() %>% 
  vip(num_features = 40) + 
  scale_y_continuous(name = "Permutation-Based Variable Importance") + 
  labs(title = "A)")


# explain_fit <- DALEXtra::explain_tidymodels(
#   tuned_fit,
#   data = training_split,
#   y = tmp$delta,
#   label = "rf",
#   colorize = TRUE,
#   verbose = FALSE
# )


# pdp_fit  <- model_profile(
#   explain_fit,
#   type = "partial",
#   N = 500
# )


# pd_plot <- plot(
#   pdp_fit,
#   geom = "points"
# ) +
#   theme_minimal() +
#   labs(title = "B)", subtitle = '', y = "Predicted Delta")

# fig <- catch_vip_plot| pd_plot

make_quadrant_predictions <- function(fit, testing_split) {
  
  predicted_quadrant <- predict(fit, testing_split)
  
  testing_split$predicted_quadrant <- predicted_quadrant$.pred_class
  
  acc <-  testing_split |>
    group_by(quadrant) |>
    summarise(accuracy = mean(quadrant == predicted_quadrant)) |>
    ungroup() |>
    mutate(mean_accuracy = mean(accuracy))
  
  confusion_matrix <- testing_split |>
    group_by(quadrant, predicted_quadrant) |>
    count() |>
    ungroup() |>
    complete(predicted_quadrant, quadrant, fill = list(n = 0)) |>
    group_by(predicted_quadrant) |>
    mutate(pn = n / sum(n), label_pn = percent(pn, accuracy = 1))
  
  out <- list(accuracy = acc, confusion_matrix = confusion_matrix)
  
}

fit_performance <- tibble(fits = fits, fit_name = names(fits)) |> 
  mutate(performance = map(fits, make_quadrant_predictions, testing_split = testing_split))

rm(fits)

fit_performance <- fit_performance |> 
  mutate(accuracy = map(performance, "accuracy"))



```

```{r}
#| label: fig-quadrant-prediction 
#| fig-cap: Confusion matrix of indicator based ensemble model of quadrant outcomes of MPAs.
#| eval: false
  

fig <- fit_performance$performance[[1]]$confusion_matrix|> 
  ggplot(aes(predicted_quadrant, quadrant)) +
  geom_tile(aes(fill = pn), color = "black") +
  geom_abline(
    color = "tomato",
    slope = 1,
    intercept = 0,
    alpha = 0.5,
    linetype = 2
  ) +
  geom_text(aes(label = n), size = 2, color = "tomato") +
  scale_fill_viridis_c(limits = c(0,1)) +
  theme(axis.text.x = element_text(
    angle = 45,
    vjust = 1,
    hjust = 1
  )) +
  scale_y_discrete(name = "Simulated Reality") +
  scale_x_discrete(name = "Ensemble Model Prediction") + 
  labs(title = "A") + 
  guides(fill = "none")
  

figsaver(fig)

  
```

```{r}
#| label: fig-tradeoffs
#| fig-cap: Distribution of simulation outcomes for total biomass (x-axis) and catch (y-axis), by proportion of seascape in MPA (rows), and scenario complexity (columns). Color indicates the business as usual degree of depletion (Biomass divided by unfished biomass) in the absence of the MPA. 
  # mutate(percent_mpa_effect = pmin(100, 100 * percent_mpa_effect))


  
  # quad_labels <- data.frame(
  #   x = c(50, 50, -24, -24),
  #   y = c(50, -50, 50, -50),
  #   label = c("Win-Win", "Win-Lose", "Lose-Win", "Lose-Lose")
  # )


  sighbreaks <- seq(-1,2, by = 1)
  sighlabs <- paste0(sighbreaks * 100, "%")
  sighlabs[length(sighlabs)] <- "≥200%"


  thirty_protected_plot <- mpa_outcomes |>
    filter(observation_error == default_observation_error) |> 
    mutate(mpa_bin = as.character(cut(numeric_prop_mpa, breaks = c(0, 0.15, 0.3, 6)))) |> 
    mutate(mpa_bin = as_factor(case_when(mpa_bin == "(0,0.15]" ~ "0-15%", mpa_bin =="(0.15,0.3]" ~ "15-30%", .default = "30-60%"))) |> 
    # filter(numeric_prop_mpa <= 0.4) |>
    # filter(between(numeric_prop_mpa, 0.2, 0.4)) |>
    ggplot(aes(biomass, catch)) +
    geom_vline(xintercept = 0, color = "black", linetype = 2) +
    geom_hline(yintercept = 0, color = "black",linetype = 2) +
    geom_point(aes(color = pmin(1,depletion)), alpha = 0.25) +
    # geom_rug(alpha = 1/4) +
    # geom_text(
    #   data = quad_labels,
    #   aes(x, y, label = label),
    #   size = 6,
    #   color = "red"
    # ) +
    scale_color_viridis_c(
      "BAU B/B0",
      limits = c(0, 1),
      option = "plasma",
      guide = guide_colorbar(
        frame.colour = "black",
        ticks.colour = "black",
        barwidth =  unit(11, "lines")
      )
    )  +
    scale_x_continuous(name = "Change in Species Biomass",
                       oob = squish,
                       limits = c(NA, 2), 
                       labels = scales::percent) +
    scale_y_continuous(name = "Change in Species Catch",
                       oob = squish,
                       limits = c(NA, 2), 
                       breaks = sighbreaks,
                       labels = sighlabs) +
    theme(legend.position = "bottom") +
    facet_grid(mpa_bin~fct_rev(difficulty))
  
  
  # thirty_protected_plot <- ggMarginal(thirty_protected_plot,
  #                                     type = "histogram",
  #                                     fill = "steelblue")
  
  
  
  figsaver(thirty_protected_plot)

  #ggplotly(thirty_protected_plot)
```

```{r}
#| label: fig-sigh
#| fig-cap: Probably won't include, but measures of performance with different model specs
#| eval: false

fit_performance |> 
  select(fit_name, accuracy) |> 
  unnest(cols = accuracy) |> 
  ggplot(aes(reorder(quadrant, accuracy), accuracy, fill = fit_name)) + 
  geom_col(position = "dodge") + 
  coord_flip()

fit_performance |> 
  select(fit_name, accuracy) |> 
  unnest(cols = accuracy) |> 
  group_by(fit_name) |> 
  summarise(accuracy = mean(mean_accuracy)) |> 
  ggplot(aes(reorder(fit_name, accuracy), accuracy)) + 
  geom_col()

```

```{r}
moreofthis <- function(tmp){

  sigh <- tmp |> 
  mutate(nprop_mpa = as.numeric(as.character(prop_mpa))) |> 
  mutate(percent_mpa_effect = pmin(percent_mpa_effect,4))|> 
  rsample::initial_split()

a = ranger(percent_mpa_effect ~ f_v_m + nprop_mpa, data = analysis(sigh))

b <- predict(a,data = assessment(sigh))

blah <- assessment(sigh) |> 
  mutate(effect_hat = b$predictions)

out <- blah |> 
  summarise(rmse = yardstick::rmse_vec(percent_mpa_effect, effect_hat),
            r2 = yardstick::rsq_vec(percent_mpa_effect, effect_hat))
}

# benchmarks <- inds_and_outs |> 
#   group_by(name) |> 
#   nest() |> 
#   mutate(tmp = map(data,moreofthis)) |> 
#   select(name, tmp) |> 
#   unnest(cols = tmp)
# 
# benchmarks
#   

measure_performance <- function(x) {
  augx <- broom::augment(x)
  # browser()
  # plot((augx$.fitted),(augx$percent_mpa_effect))
  out <- data.frame(
    rmse = yardstick::rmse_vec(augx$percent_mpa_effect, augx$.fitted),
    bias = mean(augx$percent_mpa_effect - augx$.fitted)
  )
  
}

indicator_performance <- comparison |>
  left_join(state_depletions, by = c("critter", "state_id", "difficulty")) |> 
  ungroup() |> 
  filter(observation_error == default_observation_error) |> 
  filter(is.finite(percent_mpa_effect), is.finite(indicator_value)) |>
  filter(!is.na(indicator)) |>
  mutate(percent_mpa_effect = percent_mpa_effect) |>
  group_by(name, indicator) |>
  nest() |>
  mutate(model = map(data, ~ lm(
    percent_mpa_effect ~ indicator_value, data = .x
  ))) |>
  mutate(model_summary = map(model, broom::glance)) |>
  mutate(model_performance = map(model, measure_performance)) |>
  unnest(cols = c(model_summary, model_performance)) |>
  select(-model, -data)

best_indicators <- indicator_performance |>
  group_by(name) |>
  filter(rmse == min(rmse)) |>
  rename(best_indicator = indicator)

difficulty_indicator_performance <- comparison |>
  ungroup() |>
  filter(observation_error == default_observation_error) |>
  filter(is.finite(percent_mpa_effect), is.finite(indicator_value)) |>
  filter(!is.na(indicator)) |>
  mutate(percent_mpa_effect = percent_mpa_effect) |>
  group_by(name, indicator, difficulty) |>
  nest() |>
  mutate(model = map(data, ~ lm(
    percent_mpa_effect ~ indicator_value, data = .x
  ))) |>
  mutate(model_summary = map(model, broom::glance)) |>
  mutate(model_performance = map(model, measure_performance)) |>
  unnest(cols = c(model_summary, model_performance)) |>
  select(-model, -data) |>
  ungroup() |> 
  mutate(
    name = fct_recode(
      name,
      "Biomass Outside" = "fished_biomass",
      "Biomass Inside" = "mpa_biomass",
      "Total Biomass" = "biomass",
      "Catch" = "catch"
    )
  ) |> 
  mutate(combo = paste(name, indicator, sep = " ~ ")) |>
  mutate(combo = str_remove_all(combo, "ind_"))


best_performers <- comparison |>
  left_join(best_indicators, by = "name") |>
  filter(observation_error == default_observation_error) |> 
  filter(indicator == best_indicator) |>
    mutate(
    name = fct_recode(
      name,
      "Biomass Outside" = "fished_biomass",
      "Biomass Inside" = "mpa_biomass",
      "Total Biomass" = "biomass",
      "Catch" = "catch"
    )
  ) |> 
  mutate(combo = paste(name, indicator, sep = " ~ ")) |>
  mutate(combo = str_remove_all(combo, "ind_"))


best_indicators_noncausal <- indicator_performance |>
  filter(str_detect(indicator, ("_rr|_gradient"))) |>
  group_by(name) |>
  filter(rmse == min(rmse)) |>
  rename(best_indicator = indicator)

best_performers_noncausal <- comparison |>
    filter(observation_error == default_observation_error) |> 
  filter(str_detect(indicator, ("_rr|_gradient"))) |>
  left_join(best_indicators_noncausal, by = "name") |>
  filter(indicator == best_indicator) |>
  mutate(combo = paste(name, indicator, sep = " ~ ")) |>
  mutate(combo = str_remove_all(combo, "ind_"))
```

```{r}
#|label: total-ind-performance
#|
measure_performance <- function(x){
  
  augx <- broom::augment(x)
  # browser()
  # plot(exp(augx$.fitted),exp(augx$log_percent_mpa_effect))
  out <- data.frame(rmse = yardstick::rmse_vec(augx$percent_mpa_effect, augx$.fitted),
                    bias = mean(augx$percent_mpa_effect- augx$.fitted))
  
}

total_indicator_performance <- total_comparison |>
  filter(observation_error == default_observation_error) |> 
  filter(is.finite(percent_mpa_effect), is.finite(indicator_value)) |> 
  filter(!is.na(indicator)) |> 
    mutate(percent_mpa_effect = percent_mpa_effect) |> 
  group_by(name, indicator) |>
  nest() |>
  mutate(model = map(data, ~ lm(
    percent_mpa_effect ~ indicator_value, data = .x
  ))) |> 
  mutate(model_summary = map(model, broom::glance)) |> 
  mutate(model_performance = map(model, measure_performance)) |> 
  unnest(cols = c(model_summary,model_performance)) |> 
  select(-model,-data) |> 
  mutate(rmse = pmin(5,rmse))

best_total_indicators <- total_indicator_performance |> 
  group_by(name) |> 
  filter(r.squared == max(r.squared)) |> 
  rename(best_indicator = indicator)

best_total_performers <- total_comparison |> 
    filter(observation_error == default_observation_error) |> 
  left_join(best_total_indicators, by ="name") |> 
  filter(indicator == best_indicator) |> 
  mutate(combo = paste(name, indicator, sep = " ~ ")) |> 
  mutate(combo = str_remove_all(combo, "ind_"))
  

best_total_indicators_noncausal <- total_indicator_performance |> 
  filter(str_detect(indicator,("_rr|_gradient"))) |> 
  group_by(name) |> 
  filter(rmse == min(rmse)) |> 
  rename(best_indicator = indicator)

best_total_performers_noncausal <- total_comparison |> 
  filter(str_detect(indicator,("_rr|_gradient"))) |> 
  left_join(best_total_indicators_noncausal, by ="name") |> 
  filter(indicator == best_indicator) |> 
  mutate(combo = paste(name, indicator, sep = " ~ ")) |> 
    mutate(combo = str_remove_all(combo, "ind_"))

```

```{r}
#| label: fig-top-performers
#| fig-cap: Indicator value (x-axis) and outcome value (y-axis) for the best performing indicator for the outcome in question (row label) broken out by simulation complexity (rows). Candidate indicators include those with access to data before, after,inside, and outside of MPAs. 'baci' stande for Before-After-Control-Impact, 'rr' stands for Response Ratio, 'ba' stands for Before-After.


tmp <- best_performers |>
  left_join(state_depletions) |>
  ungroup() |>
  slice_sample(prop = 0.6) |> 
  ungroup() |> 
   mutate(combo = str_remove_all(combo, "biomass_")) |>
  mutate(combo = fct_relevel(combo, "Biomass Inside ~ baci", "Biomass Outside ~ rr"  ,"Total Biomass ~ baci"))
# 

model_summary <- difficulty_indicator_performance |>
  ungroup() |> 
  mutate(combo = str_remove_all(combo, "biomass_")) |>
  mutate(combo = fct_relevel(combo, "Biomass Inside ~ baci","Biomass Outside ~ rr"  ,"Total Biomass ~ baci")) |> 
  filter(combo %in% tmp$combo)

a = tmp |> 
  filter(str_detect(combo, "Catch")) |> 
  group_by(difficulty) |> 
  summarise(max(indicator_value))

fig <- tmp |>
  group_by(indicator) |>
  mutate(indicator_value = indicator_value) |>
  ggplot(aes(indicator_value, percent_mpa_effect)) +
  geom_point(aes(color = depletion), alpha = 0.25) +
  geom_rug(alpha = 1 / 4) +
  # geom_hex(bins = 10) +
  geom_hline(yintercept = 0,
             linetype = 2,
             color = "tomato") +
  geom_vline(xintercept = 0,
             linetype = 2,
             color = "tomato") +
  geom_richtext(data = model_summary, aes(
    x = 2,
    y = 1,
    label = glue("R<sup>2</sup> = {round(r.squared,2)}")
  )) +
  facet_grid(fct_rev(difficulty) ~ combo, scales = "free_x") +
  scale_y_continuous(
    oob = squish,
    labels = scales::percent,
    name = "MPA Effect",
    limits = c(NA, 2)
  ) +
  scale_x_continuous(name = "BACI Estimate", limits = c(NA,2)) +
  scale_color_viridis_c(
    "BAU B/B0",
    limits = c(0, 1.1),
    option = "plasma",
    guide = guide_colorbar(
      frame.colour = "black",
      ticks.colour = "black",
      barwidth =  unit(11, "lines")
    )
  )  +    theme(legend.position = "bottom")

figsaver(fig)

```

```{r}
#| label: tbl-test

r2_table <- indicator_performance |> 
  mutate(indicator = str_remove_all(indicator, "ind_")) |> 
  select(name, indicator, r.squared) |> 
  mutate(r.squared = round(r.squared / 0.01) * 0.01) |> 
  group_by(name) |> 
  mutate(order = mean(r.squared)) |> 
  ungroup() |> 
  mutate(indicator = fct_reorder(indicator,r.squared)) |> 
  arrange(rev(indicator)) |> 
  select(-order) |> 
  pivot_wider(names_from = name, values_from = r.squared) |> 
  ungroup() |> 
  mutate(metric = "R2") |> 
  select(indicator, metric, everything())


rmse_table <- indicator_performance |> 
  mutate(indicator = str_remove_all(indicator, "ind_")) |> 
  select(name, indicator, rmse) |> 
  mutate(rmse = round(rmse / 0.01) * 0.01) |> 
  group_by(name) |> 
  mutate(order = mean(rmse)) |> 
  ungroup() |> 
  mutate(indicator = fct_reorder(indicator,rmse)) |> 
  arrange(rev(indicator)) |> 
  select(-order) |> 
  pivot_wider(names_from = name, values_from = rmse) |> 
  ungroup() |> 
  mutate(metric = "RMSE") |> 
  select(indicator, metric, everything())

metric_table <- r2_table |> 
  bind_rows(rmse_table) |> 
  arrange(indicator)


metric_table |> 
  gt() |> 
  tab_caption("R2 and RMSE of each tested indicator as a predictor of each considered outcome. Will clean this up xx.")
 
```
